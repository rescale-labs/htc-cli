// Code generated by ogen, DO NOT EDIT.

package _oas

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes Architecture as json.
func (s Architecture) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Architecture from json.
func (s *Architecture) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Architecture to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Architecture(v) {
	case ArchitectureAARCH64:
		*s = ArchitectureAARCH64
	case ArchitectureX86:
		*s = ArchitectureX86
	case ArchitectureA100:
		*s = ArchitectureA100
	default:
		*s = Architecture(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Architecture) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Architecture) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutoscalingConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutoscalingConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.MaxNodeCount.Set {
			e.FieldStart("maxNodeCount")
			s.MaxNodeCount.Encode(e)
		}
	}
	{
		if s.MinNodeCount.Set {
			e.FieldStart("minNodeCount")
			s.MinNodeCount.Encode(e)
		}
	}
}

var jsonFieldsNameOfAutoscalingConfig = [3]string{
	0: "enabled",
	1: "maxNodeCount",
	2: "minNodeCount",
}

// Decode decodes AutoscalingConfig from json.
func (s *AutoscalingConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoscalingConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "maxNodeCount":
			if err := func() error {
				s.MaxNodeCount.Reset()
				if err := s.MaxNodeCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxNodeCount\"")
			}
		case "minNodeCount":
			if err := func() error {
				s.MinNodeCount.Reset()
				if err := s.MinNodeCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minNodeCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutoscalingConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutoscalingConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoscalingConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoscalingProfile as json.
func (s AutoscalingProfile) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AutoscalingProfile from json.
func (s *AutoscalingProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutoscalingProfile to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AutoscalingProfile(v) {
	case AutoscalingProfilePROFILEUNSPECIFIED:
		*s = AutoscalingProfilePROFILEUNSPECIFIED
	case AutoscalingProfileOPTIMIZEUTILIZATION:
		*s = AutoscalingProfileOPTIMIZEUTILIZATION
	case AutoscalingProfileBALANCED:
		*s = AutoscalingProfileBALANCED
	case AutoscalingProfileUNRECOGNIZED:
		*s = AutoscalingProfileUNRECOGNIZED
	default:
		*s = AutoscalingProfile(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutoscalingProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutoscalingProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CloudProvider as json.
func (s CloudProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CloudProvider from json.
func (s *CloudProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CloudProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CloudProvider(v) {
	case CloudProviderAWS:
		*s = CloudProviderAWS
	case CloudProviderGCP:
		*s = CloudProviderGCP
	case CloudProviderNGC:
		*s = CloudProviderNGC
	case CloudProviderAZURE:
		*s = CloudProviderAZURE
	case CloudProviderRC:
		*s = CloudProviderRC
	case CloudProviderUNASSIGNED:
		*s = CloudProviderUNASSIGNED
	default:
		*s = CloudProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CloudProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CloudProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ContainerDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ContainerDetails) encodeFields(e *jx.Encoder) {
	{
		if s.ExitCode.Set {
			e.FieldStart("exitCode")
			s.ExitCode.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfContainerDetails = [2]string{
	0: "exitCode",
	1: "reason",
}

// Decode decodes ContainerDetails from json.
func (s *ContainerDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ContainerDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exitCode":
			if err := func() error {
				s.ExitCode.Reset()
				if err := s.ExitCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exitCode\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ContainerDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ContainerDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ContainerDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnvPair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnvPair) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfEnvPair = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes EnvPair from json.
func (s *EnvPair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnvPair to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnvPair")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnvPair) {
					name = jsonFieldsNameOfEnvPair[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnvPair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnvPair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExperimentalFields) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExperimentalFields) encodeFields(e *jx.Encoder) {
	{
		if s.KubernetesSwap.Set {
			e.FieldStart("kubernetesSwap")
			s.KubernetesSwap.Encode(e)
		}
	}
}

var jsonFieldsNameOfExperimentalFields = [1]string{
	0: "kubernetesSwap",
}

// Decode decodes ExperimentalFields from json.
func (s *ExperimentalFields) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExperimentalFields to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "kubernetesSwap":
			if err := func() error {
				s.KubernetesSwap.Reset()
				if err := s.KubernetesSwap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kubernetesSwap\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExperimentalFields")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExperimentalFields) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExperimentalFields) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FeatureFlagsResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FeatureFlagsResult) encodeFields(e *jx.Encoder) {
	{
		if s.Count.Set {
			e.FieldStart("count")
			s.Count.Encode(e)
		}
	}
	{
		if s.Results != nil {
			e.FieldStart("results")
			e.ArrStart()
			for _, elem := range s.Results {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfFeatureFlagsResult = [2]string{
	0: "count",
	1: "results",
}

// Decode decodes FeatureFlagsResult from json.
func (s *FeatureFlagsResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FeatureFlagsResult to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "count":
			if err := func() error {
				s.Count.Reset()
				if err := s.Count.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		case "results":
			if err := func() error {
				s.Results = make([]RescaleFlag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RescaleFlag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Results = append(s.Results, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"results\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FeatureFlagsResult")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FeatureFlagsResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FeatureFlagsResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCCluster) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCCluster) encodeFields(e *jx.Encoder) {
	{
		if s.Autoscaling.Set {
			e.FieldStart("autoscaling")
			s.Autoscaling.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NodePools != nil {
			e.FieldStart("nodePools")
			e.ArrStart()
			for _, elem := range s.NodePools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Subnetwork.Set {
			e.FieldStart("subnetwork")
			s.Subnetwork.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCCluster = [7]string{
	0: "autoscaling",
	1: "name",
	2: "nodePools",
	3: "region",
	4: "status",
	5: "subnetwork",
	6: "version",
}

// Decode decodes HTCCluster from json.
func (s *HTCCluster) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCCluster to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "autoscaling":
			if err := func() error {
				s.Autoscaling.Reset()
				if err := s.Autoscaling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoscaling\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodePools":
			if err := func() error {
				s.NodePools = make([]HTCNodePool, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTCNodePool
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodePools = append(s.NodePools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodePools\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "subnetwork":
			if err := func() error {
				s.Subnetwork.Reset()
				if err := s.Subnetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subnetwork\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCCluster")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCCluster) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCCluster) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCClusterStatusResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCClusterStatusResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Clusters != nil {
			e.FieldStart("clusters")
			e.ArrStart()
			for _, elem := range s.Clusters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.GcpProjectId.Set {
			e.FieldStart("gcpProjectId")
			s.GcpProjectId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCClusterStatusResponse = [2]string{
	0: "clusters",
	1: "gcpProjectId",
}

// Decode decodes HTCClusterStatusResponse from json.
func (s *HTCClusterStatusResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCClusterStatusResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusters":
			if err := func() error {
				s.Clusters = make([]HTCCluster, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTCCluster
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Clusters = append(s.Clusters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusters\"")
			}
		case "gcpProjectId":
			if err := func() error {
				s.GcpProjectId.Reset()
				if err := s.GcpProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gcpProjectId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCClusterStatusResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCClusterStatusResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCClusterStatusResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCComputeEnvironment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCComputeEnvironment) encodeFields(e *jx.Encoder) {
	{
		if s.ComputeScalingPolicy.Set {
			e.FieldStart("computeScalingPolicy")
			s.ComputeScalingPolicy.Encode(e)
		}
	}
	{
		if s.Derived.Set {
			e.FieldStart("derived")
			s.Derived.Encode(e)
		}
	}
	{
		if s.Hyperthreading.Set {
			e.FieldStart("hyperthreading")
			s.Hyperthreading.Encode(e)
		}
	}
	{
		if s.MachineType.Set {
			e.FieldStart("machineType")
			s.MachineType.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCComputeEnvironment = [6]string{
	0: "computeScalingPolicy",
	1: "derived",
	2: "hyperthreading",
	3: "machineType",
	4: "priority",
	5: "region",
}

// Decode decodes HTCComputeEnvironment from json.
func (s *HTCComputeEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCComputeEnvironment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "computeScalingPolicy":
			if err := func() error {
				s.ComputeScalingPolicy.Reset()
				if err := s.ComputeScalingPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computeScalingPolicy\"")
			}
		case "derived":
			if err := func() error {
				s.Derived.Reset()
				if err := s.Derived.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"derived\"")
			}
		case "hyperthreading":
			if err := func() error {
				s.Hyperthreading.Reset()
				if err := s.Hyperthreading.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hyperthreading\"")
			}
		case "machineType":
			if err := func() error {
				s.MachineType.Reset()
				if err := s.MachineType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"machineType\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCComputeEnvironment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCComputeEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCComputeEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentComputeScalingPolicy as json.
func (s HTCComputeEnvironmentComputeScalingPolicy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCComputeEnvironmentComputeScalingPolicy from json.
func (s *HTCComputeEnvironmentComputeScalingPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCComputeEnvironmentComputeScalingPolicy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCComputeEnvironmentComputeScalingPolicy(v) {
	case HTCComputeEnvironmentComputeScalingPolicyPROFILEUNSPECIFIED:
		*s = HTCComputeEnvironmentComputeScalingPolicyPROFILEUNSPECIFIED
	case HTCComputeEnvironmentComputeScalingPolicyOPTIMIZEUTILIZATION:
		*s = HTCComputeEnvironmentComputeScalingPolicyOPTIMIZEUTILIZATION
	case HTCComputeEnvironmentComputeScalingPolicyBALANCED:
		*s = HTCComputeEnvironmentComputeScalingPolicyBALANCED
	case HTCComputeEnvironmentComputeScalingPolicyUNRECOGNIZED:
		*s = HTCComputeEnvironmentComputeScalingPolicyUNRECOGNIZED
	default:
		*s = HTCComputeEnvironmentComputeScalingPolicy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCComputeEnvironmentComputeScalingPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCComputeEnvironmentComputeScalingPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCComputeEnvironmentDerived) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCComputeEnvironmentDerived) encodeFields(e *jx.Encoder) {
	{
		if s.Architecture.Set {
			e.FieldStart("architecture")
			s.Architecture.Encode(e)
		}
	}
	{
		if s.Memory.Set {
			e.FieldStart("memory")
			s.Memory.Encode(e)
		}
	}
	{
		if s.Swap.Set {
			e.FieldStart("swap")
			s.Swap.Encode(e)
		}
	}
	{
		if s.VCPUs.Set {
			e.FieldStart("vCPUs")
			s.VCPUs.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCComputeEnvironmentDerived = [4]string{
	0: "architecture",
	1: "memory",
	2: "swap",
	3: "vCPUs",
}

// Decode decodes HTCComputeEnvironmentDerived from json.
func (s *HTCComputeEnvironmentDerived) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCComputeEnvironmentDerived to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "architecture":
			if err := func() error {
				s.Architecture.Reset()
				if err := s.Architecture.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "memory":
			if err := func() error {
				s.Memory.Reset()
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "swap":
			if err := func() error {
				s.Swap.Reset()
				if err := s.Swap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swap\"")
			}
		case "vCPUs":
			if err := func() error {
				s.VCPUs.Reset()
				if err := s.VCPUs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vCPUs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCComputeEnvironmentDerived")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCComputeEnvironmentDerived) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCComputeEnvironmentDerived) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentDerivedArchitecture as json.
func (s HTCComputeEnvironmentDerivedArchitecture) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCComputeEnvironmentDerivedArchitecture from json.
func (s *HTCComputeEnvironmentDerivedArchitecture) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCComputeEnvironmentDerivedArchitecture to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCComputeEnvironmentDerivedArchitecture(v) {
	case HTCComputeEnvironmentDerivedArchitectureAARCH64:
		*s = HTCComputeEnvironmentDerivedArchitectureAARCH64
	case HTCComputeEnvironmentDerivedArchitectureX86:
		*s = HTCComputeEnvironmentDerivedArchitectureX86
	case HTCComputeEnvironmentDerivedArchitectureA100:
		*s = HTCComputeEnvironmentDerivedArchitectureA100
	default:
		*s = HTCComputeEnvironmentDerivedArchitecture(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCComputeEnvironmentDerivedArchitecture) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCComputeEnvironmentDerivedArchitecture) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentPriority as json.
func (s HTCComputeEnvironmentPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCComputeEnvironmentPriority from json.
func (s *HTCComputeEnvironmentPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCComputeEnvironmentPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCComputeEnvironmentPriority(v) {
	case HTCComputeEnvironmentPriorityONDEMANDPRIORITY:
		*s = HTCComputeEnvironmentPriorityONDEMANDPRIORITY
	case HTCComputeEnvironmentPriorityONDEMANDECONOMY:
		*s = HTCComputeEnvironmentPriorityONDEMANDECONOMY
	default:
		*s = HTCComputeEnvironmentPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCComputeEnvironmentPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCComputeEnvironmentPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentRegion as json.
func (s HTCComputeEnvironmentRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCComputeEnvironmentRegion from json.
func (s *HTCComputeEnvironmentRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCComputeEnvironmentRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCComputeEnvironmentRegion(v) {
	case HTCComputeEnvironmentRegionAWSAPSOUTHEAST1:
		*s = HTCComputeEnvironmentRegionAWSAPSOUTHEAST1
	case HTCComputeEnvironmentRegionAWSCACENTRAL1:
		*s = HTCComputeEnvironmentRegionAWSCACENTRAL1
	case HTCComputeEnvironmentRegionAWSEUNORTH1:
		*s = HTCComputeEnvironmentRegionAWSEUNORTH1
	case HTCComputeEnvironmentRegionAWSEUCENTRAL1:
		*s = HTCComputeEnvironmentRegionAWSEUCENTRAL1
	case HTCComputeEnvironmentRegionAWSEUWEST1:
		*s = HTCComputeEnvironmentRegionAWSEUWEST1
	case HTCComputeEnvironmentRegionAWSEUWEST2:
		*s = HTCComputeEnvironmentRegionAWSEUWEST2
	case HTCComputeEnvironmentRegionAWSEUWEST3:
		*s = HTCComputeEnvironmentRegionAWSEUWEST3
	case HTCComputeEnvironmentRegionAWSSAEAST1:
		*s = HTCComputeEnvironmentRegionAWSSAEAST1
	case HTCComputeEnvironmentRegionAWSUSEAST2:
		*s = HTCComputeEnvironmentRegionAWSUSEAST2
	case HTCComputeEnvironmentRegionAWSUSWEST2:
		*s = HTCComputeEnvironmentRegionAWSUSWEST2
	case HTCComputeEnvironmentRegionAWSUSEAST1:
		*s = HTCComputeEnvironmentRegionAWSUSEAST1
	case HTCComputeEnvironmentRegionGCPASIASOUTHEAST1:
		*s = HTCComputeEnvironmentRegionGCPASIASOUTHEAST1
	case HTCComputeEnvironmentRegionGCPUSCENTRAL1:
		*s = HTCComputeEnvironmentRegionGCPUSCENTRAL1
	case HTCComputeEnvironmentRegionGCPUSEAST1:
		*s = HTCComputeEnvironmentRegionGCPUSEAST1
	case HTCComputeEnvironmentRegionGCPUSEAST2:
		*s = HTCComputeEnvironmentRegionGCPUSEAST2
	case HTCComputeEnvironmentRegionGCPUSEAST4:
		*s = HTCComputeEnvironmentRegionGCPUSEAST4
	case HTCComputeEnvironmentRegionGCPUSWEST1:
		*s = HTCComputeEnvironmentRegionGCPUSWEST1
	case HTCComputeEnvironmentRegionGCPUSWEST4:
		*s = HTCComputeEnvironmentRegionGCPUSWEST4
	case HTCComputeEnvironmentRegionGCPEUWEST1:
		*s = HTCComputeEnvironmentRegionGCPEUWEST1
	case HTCComputeEnvironmentRegionGCPEUWEST2:
		*s = HTCComputeEnvironmentRegionGCPEUWEST2
	case HTCComputeEnvironmentRegionGCPEUWEST3:
		*s = HTCComputeEnvironmentRegionGCPEUWEST3
	case HTCComputeEnvironmentRegionGCPEUWEST4:
		*s = HTCComputeEnvironmentRegionGCPEUWEST4
	case HTCComputeEnvironmentRegionGCPCACENTRAL1:
		*s = HTCComputeEnvironmentRegionGCPCACENTRAL1
	case HTCComputeEnvironmentRegionNGCENOCH1:
		*s = HTCComputeEnvironmentRegionNGCENOCH1
	case HTCComputeEnvironmentRegionAZUREUSWEST2:
		*s = HTCComputeEnvironmentRegionAZUREUSWEST2
	case HTCComputeEnvironmentRegionAZUREUSEAST2:
		*s = HTCComputeEnvironmentRegionAZUREUSEAST2
	case HTCComputeEnvironmentRegionAZUREUSSOUTHCENTRAL:
		*s = HTCComputeEnvironmentRegionAZUREUSSOUTHCENTRAL
	case HTCComputeEnvironmentRegionAZUREEUNORTH:
		*s = HTCComputeEnvironmentRegionAZUREEUNORTH
	case HTCComputeEnvironmentRegionRCICELAND1:
		*s = HTCComputeEnvironmentRegionRCICELAND1
	case HTCComputeEnvironmentRegionUNASSIGNED:
		*s = HTCComputeEnvironmentRegionUNASSIGNED
	default:
		*s = HTCComputeEnvironmentRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCComputeEnvironmentRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCComputeEnvironmentRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCImageStatus) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCImageStatus) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCImageStatus = [1]string{
	0: "status",
}

// Decode decodes HTCImageStatus from json.
func (s *HTCImageStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCImageStatus to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCImageStatus")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCImageStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCImageStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCImages) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCImages) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerRegistry.Set {
			e.FieldStart("containerRegistry")
			s.ContainerRegistry.Encode(e)
		}
	}
	{
		if s.Images != nil {
			e.FieldStart("images")
			e.ArrStart()
			for _, elem := range s.Images {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHTCImages = [2]string{
	0: "containerRegistry",
	1: "images",
}

// Decode decodes HTCImages from json.
func (s *HTCImages) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCImages to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerRegistry":
			if err := func() error {
				s.ContainerRegistry.Reset()
				if err := s.ContainerRegistry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerRegistry\"")
			}
		case "images":
			if err := func() error {
				s.Images = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Images = append(s.Images, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"images\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCImages")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCImages) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCImages) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCInfraResource) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCInfraResource) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.ResourceStatus.Set {
			e.FieldStart("resourceStatus")
			s.ResourceStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCInfraResource = [3]string{
	0: "name",
	1: "resourceId",
	2: "resourceStatus",
}

// Decode decodes HTCInfraResource from json.
func (s *HTCInfraResource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCInfraResource to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "resourceStatus":
			if err := func() error {
				s.ResourceStatus.Reset()
				if err := s.ResourceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCInfraResource")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCInfraResource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCInfraResource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCJob) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCJob) encodeFields(e *jx.Encoder) {
	{
		if s.Architecture.Set {
			e.FieldStart("architecture")
			s.Architecture.Encode(e)
		}
	}
	{
		if s.Commands != nil {
			e.FieldStart("commands")
			e.ArrStart()
			for _, elem := range s.Commands {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CompletedAt.Set {
			e.FieldStart("completedAt")
			s.CompletedAt.Encode(e)
		}
	}
	{
		if s.Container.Set {
			e.FieldStart("container")
			s.Container.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.Envs != nil {
			e.FieldStart("envs")
			e.ArrStart()
			for _, elem := range s.Envs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExecTimeoutSeconds.Set {
			e.FieldStart("execTimeoutSeconds")
			s.ExecTimeoutSeconds.Encode(e)
		}
	}
	{
		if s.FailureCode.Set {
			e.FieldStart("failureCode")
			s.FailureCode.Encode(e)
		}
	}
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
	{
		if s.ImageName.Set {
			e.FieldStart("imageName")
			s.ImageName.Encode(e)
		}
	}
	{
		if s.InstanceId.Set {
			e.FieldStart("instanceId")
			s.InstanceId.Encode(e)
		}
	}
	{
		if s.InstanceLabels.Set {
			e.FieldStart("instanceLabels")
			s.InstanceLabels.Encode(e)
		}
	}
	{
		if s.JobExecutionEnvironment.Set {
			e.FieldStart("jobExecutionEnvironment")
			s.JobExecutionEnvironment.Encode(e)
		}
	}
	{
		if s.JobUUID.Set {
			e.FieldStart("jobUUID")
			s.JobUUID.Encode(e)
		}
	}
	{
		if s.MaxDiskGiB.Set {
			e.FieldStart("maxDiskGiB")
			s.MaxDiskGiB.Encode(e)
		}
	}
	{
		if s.MaxMemory.Set {
			e.FieldStart("maxMemory")
			s.MaxMemory.Encode(e)
		}
	}
	{
		if s.MaxSwap.Set {
			e.FieldStart("maxSwap")
			s.MaxSwap.Encode(e)
		}
	}
	{
		if s.MaxVCpus.Set {
			e.FieldStart("maxVCpus")
			s.MaxVCpus.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		if s.ProviderJobId.Set {
			e.FieldStart("providerJobId")
			s.ProviderJobId.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.StartedAt.Set {
			e.FieldStart("startedAt")
			s.StartedAt.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.StatusReason.Set {
			e.FieldStart("statusReason")
			s.StatusReason.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e)
		}
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCJob = [29]string{
	0:  "architecture",
	1:  "commands",
	2:  "completedAt",
	3:  "container",
	4:  "createdAt",
	5:  "createdBy",
	6:  "envs",
	7:  "execTimeoutSeconds",
	8:  "failureCode",
	9:  "group",
	10: "imageName",
	11: "instanceId",
	12: "instanceLabels",
	13: "jobExecutionEnvironment",
	14: "jobUUID",
	15: "maxDiskGiB",
	16: "maxMemory",
	17: "maxSwap",
	18: "maxVCpus",
	19: "projectId",
	20: "providerJobId",
	21: "region",
	22: "startedAt",
	23: "status",
	24: "statusReason",
	25: "tags",
	26: "taskId",
	27: "updatedAt",
	28: "workspaceId",
}

// Decode decodes HTCJob from json.
func (s *HTCJob) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCJob to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "architecture":
			if err := func() error {
				s.Architecture.Reset()
				if err := s.Architecture.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "commands":
			if err := func() error {
				s.Commands = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Commands = append(s.Commands, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commands\"")
			}
		case "completedAt":
			if err := func() error {
				s.CompletedAt.Reset()
				if err := s.CompletedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"completedAt\"")
			}
		case "container":
			if err := func() error {
				s.Container.Reset()
				if err := s.Container.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"container\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "envs":
			if err := func() error {
				s.Envs = make([]EnvPair, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnvPair
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Envs = append(s.Envs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"envs\"")
			}
		case "execTimeoutSeconds":
			if err := func() error {
				s.ExecTimeoutSeconds.Reset()
				if err := s.ExecTimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execTimeoutSeconds\"")
			}
		case "failureCode":
			if err := func() error {
				s.FailureCode.Reset()
				if err := s.FailureCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failureCode\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "imageName":
			if err := func() error {
				s.ImageName.Reset()
				if err := s.ImageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageName\"")
			}
		case "instanceId":
			if err := func() error {
				s.InstanceId.Reset()
				if err := s.InstanceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceId\"")
			}
		case "instanceLabels":
			if err := func() error {
				s.InstanceLabels.Reset()
				if err := s.InstanceLabels.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceLabels\"")
			}
		case "jobExecutionEnvironment":
			if err := func() error {
				s.JobExecutionEnvironment.Reset()
				if err := s.JobExecutionEnvironment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobExecutionEnvironment\"")
			}
		case "jobUUID":
			if err := func() error {
				s.JobUUID.Reset()
				if err := s.JobUUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobUUID\"")
			}
		case "maxDiskGiB":
			if err := func() error {
				s.MaxDiskGiB.Reset()
				if err := s.MaxDiskGiB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxDiskGiB\"")
			}
		case "maxMemory":
			if err := func() error {
				s.MaxMemory.Reset()
				if err := s.MaxMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxMemory\"")
			}
		case "maxSwap":
			if err := func() error {
				s.MaxSwap.Reset()
				if err := s.MaxSwap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSwap\"")
			}
		case "maxVCpus":
			if err := func() error {
				s.MaxVCpus.Reset()
				if err := s.MaxVCpus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxVCpus\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "providerJobId":
			if err := func() error {
				s.ProviderJobId.Reset()
				if err := s.ProviderJobId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerJobId\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "startedAt":
			if err := func() error {
				s.StartedAt.Reset()
				if err := s.StartedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startedAt\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "statusReason":
			if err := func() error {
				s.StatusReason.Reset()
				if err := s.StatusReason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusReason\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCJob")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCJob) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCJob) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCJobDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCJobDefinition) encodeFields(e *jx.Encoder) {
	{
		if s.Architecture.Set {
			e.FieldStart("architecture")
			s.Architecture.Encode(e)
		}
	}
	{
		if s.Claims != nil {
			e.FieldStart("claims")
			e.ArrStart()
			for _, elem := range s.Claims {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Commands != nil {
			e.FieldStart("commands")
			e.ArrStart()
			for _, elem := range s.Commands {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Envs != nil {
			e.FieldStart("envs")
			e.ArrStart()
			for _, elem := range s.Envs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExecTimeoutSeconds.Set {
			e.FieldStart("execTimeoutSeconds")
			s.ExecTimeoutSeconds.Encode(e)
		}
	}
	{
		e.FieldStart("imageName")
		e.Str(s.ImageName)
	}
	{
		if s.MaxDiskGiB.Set {
			e.FieldStart("maxDiskGiB")
			s.MaxDiskGiB.Encode(e)
		}
	}
	{
		if s.MaxMemory.Set {
			e.FieldStart("maxMemory")
			s.MaxMemory.Encode(e)
		}
	}
	{
		if s.MaxSwap.Set {
			e.FieldStart("maxSwap")
			s.MaxSwap.Encode(e)
		}
	}
	{
		if s.MaxVCpus.Set {
			e.FieldStart("maxVCpus")
			s.MaxVCpus.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCJobDefinition = [12]string{
	0:  "architecture",
	1:  "claims",
	2:  "commands",
	3:  "envs",
	4:  "execTimeoutSeconds",
	5:  "imageName",
	6:  "maxDiskGiB",
	7:  "maxMemory",
	8:  "maxSwap",
	9:  "maxVCpus",
	10: "priority",
	11: "tags",
}

// Decode decodes HTCJobDefinition from json.
func (s *HTCJobDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCJobDefinition to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "architecture":
			if err := func() error {
				s.Architecture.Reset()
				if err := s.Architecture.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "claims":
			if err := func() error {
				s.Claims = make([]NameValuePair, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NameValuePair
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Claims = append(s.Claims, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"claims\"")
			}
		case "commands":
			if err := func() error {
				s.Commands = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Commands = append(s.Commands, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commands\"")
			}
		case "envs":
			if err := func() error {
				s.Envs = make([]EnvPair, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnvPair
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Envs = append(s.Envs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"envs\"")
			}
		case "execTimeoutSeconds":
			if err := func() error {
				s.ExecTimeoutSeconds.Reset()
				if err := s.ExecTimeoutSeconds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"execTimeoutSeconds\"")
			}
		case "imageName":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ImageName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"imageName\"")
			}
		case "maxDiskGiB":
			if err := func() error {
				s.MaxDiskGiB.Reset()
				if err := s.MaxDiskGiB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxDiskGiB\"")
			}
		case "maxMemory":
			if err := func() error {
				s.MaxMemory.Reset()
				if err := s.MaxMemory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxMemory\"")
			}
		case "maxSwap":
			if err := func() error {
				s.MaxSwap.Reset()
				if err := s.MaxSwap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSwap\"")
			}
		case "maxVCpus":
			if err := func() error {
				s.MaxVCpus.Reset()
				if err := s.MaxVCpus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxVCpus\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCJobDefinition")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCJobDefinition) {
					name = jsonFieldsNameOfHTCJobDefinition[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCJobDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCJobDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HTCJobDefinitionTags) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HTCJobDefinitionTags) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes HTCJobDefinitionTags from json.
func (s *HTCJobDefinitionTags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCJobDefinitionTags to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCJobDefinitionTags")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCJobDefinitionTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCJobDefinitionTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCJobFailureCode as json.
func (s HTCJobFailureCode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCJobFailureCode from json.
func (s *HTCJobFailureCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCJobFailureCode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCJobFailureCode(v) {
	case HTCJobFailureCodeErrorUnknownFailure:
		*s = HTCJobFailureCodeErrorUnknownFailure
	case HTCJobFailureCodeErrorTimeout:
		*s = HTCJobFailureCodeErrorTimeout
	case HTCJobFailureCodeErrorNotEnoughMemory:
		*s = HTCJobFailureCodeErrorNotEnoughMemory
	case HTCJobFailureCodeErrorNonZeroContainerExitCode:
		*s = HTCJobFailureCodeErrorNonZeroContainerExitCode
	case HTCJobFailureCodeErrorCostExceeded:
		*s = HTCJobFailureCodeErrorCostExceeded
	case HTCJobFailureCodeErrorInfrastructureFault:
		*s = HTCJobFailureCodeErrorInfrastructureFault
	case HTCJobFailureCodeErrorInstanceTermination:
		*s = HTCJobFailureCodeErrorInstanceTermination
	case HTCJobFailureCodeErrorStartingContainer:
		*s = HTCJobFailureCodeErrorStartingContainer
	case HTCJobFailureCodeErrorProviderDown:
		*s = HTCJobFailureCodeErrorProviderDown
	case HTCJobFailureCodeErrorProviderRegionDown:
		*s = HTCJobFailureCodeErrorProviderRegionDown
	default:
		*s = HTCJobFailureCode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCJobFailureCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCJobFailureCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCJobSubmitRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCJobSubmitRequest) encodeFields(e *jx.Encoder) {
	{
		if s.BatchSize.Set {
			e.FieldStart("batchSize")
			s.BatchSize.Encode(e)
		}
	}
	{
		if s.CloudProvider.Set {
			e.FieldStart("cloudProvider")
			s.CloudProvider.Encode(e)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.Experimental.Set {
			e.FieldStart("experimental")
			s.Experimental.Encode(e)
		}
	}
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
	{
		e.FieldStart("htcJobDefinition")
		s.HtcJobDefinition.Encode(e)
	}
	{
		if s.JobDefinitionName.Set {
			e.FieldStart("jobDefinitionName")
			s.JobDefinitionName.Encode(e)
		}
	}
	{
		if s.JobName.Set {
			e.FieldStart("jobName")
			s.JobName.Encode(e)
		}
	}
	{
		if s.ParentJobId.Set {
			e.FieldStart("parentJobId")
			s.ParentJobId.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		if s.Regions != nil {
			e.FieldStart("regions")
			e.ArrStart()
			for _, elem := range s.Regions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RescaleTimeReceived.Set {
			e.FieldStart("rescaleTimeReceived")
			s.RescaleTimeReceived.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.RetryStrategy.Set {
			e.FieldStart("retryStrategy")
			s.RetryStrategy.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCJobSubmitRequest = [16]string{
	0:  "batchSize",
	1:  "cloudProvider",
	2:  "createdBy",
	3:  "experimental",
	4:  "group",
	5:  "htcJobDefinition",
	6:  "jobDefinitionName",
	7:  "jobName",
	8:  "parentJobId",
	9:  "projectId",
	10: "regions",
	11: "rescaleTimeReceived",
	12: "retryStrategy",
	13: "tags",
	14: "taskId",
	15: "workspaceId",
}

// Decode decodes HTCJobSubmitRequest from json.
func (s *HTCJobSubmitRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCJobSubmitRequest to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "batchSize":
			if err := func() error {
				s.BatchSize.Reset()
				if err := s.BatchSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"batchSize\"")
			}
		case "cloudProvider":
			if err := func() error {
				s.CloudProvider.Reset()
				if err := s.CloudProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cloudProvider\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "experimental":
			if err := func() error {
				s.Experimental.Reset()
				if err := s.Experimental.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"experimental\"")
			}
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		case "htcJobDefinition":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.HtcJobDefinition.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"htcJobDefinition\"")
			}
		case "jobDefinitionName":
			if err := func() error {
				s.JobDefinitionName.Reset()
				if err := s.JobDefinitionName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobDefinitionName\"")
			}
		case "jobName":
			if err := func() error {
				s.JobName.Reset()
				if err := s.JobName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jobName\"")
			}
		case "parentJobId":
			if err := func() error {
				s.ParentJobId.Reset()
				if err := s.ParentJobId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parentJobId\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "regions":
			if err := func() error {
				s.Regions = make([]RescaleRegion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RescaleRegion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Regions = append(s.Regions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regions\"")
			}
		case "rescaleTimeReceived":
			if err := func() error {
				s.RescaleTimeReceived.Reset()
				if err := s.RescaleTimeReceived.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rescaleTimeReceived\"")
			}
		case "retryStrategy":
			if err := func() error {
				s.RetryStrategy.Reset()
				if err := s.RetryStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retryStrategy\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]Tag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Tag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCJobSubmitRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00100000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCJobSubmitRequest) {
					name = jsonFieldsNameOfHTCJobSubmitRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCJobSubmitRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCJobSubmitRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCJobSubmitRequests as json.
func (s HTCJobSubmitRequests) Encode(e *jx.Encoder) {
	unwrapped := []HTCJobSubmitRequest(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes HTCJobSubmitRequests from json.
func (s *HTCJobSubmitRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCJobSubmitRequests to nil")
	}
	var unwrapped []HTCJobSubmitRequest
	if err := func() error {
		unwrapped = make([]HTCJobSubmitRequest, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HTCJobSubmitRequest
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HTCJobSubmitRequests(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCJobSubmitRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCJobSubmitRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCJobs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCJobs) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCJobs = [2]string{
	0: "items",
	1: "next",
}

// Decode decodes HTCJobs from json.
func (s *HTCJobs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCJobs to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]HTCJob, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTCJob
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCJobs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCJobs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCJobs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCLimitCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCLimitCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("modifierRole")
		s.ModifierRole.Encode(e)
	}
	{
		e.FieldStart("vCPUs")
		e.Int32(s.VCPUs)
	}
}

var jsonFieldsNameOfHTCLimitCreate = [2]string{
	0: "modifierRole",
	1: "vCPUs",
}

// Decode decodes HTCLimitCreate from json.
func (s *HTCLimitCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCLimitCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "modifierRole":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ModifierRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifierRole\"")
			}
		case "vCPUs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.VCPUs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vCPUs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCLimitCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCLimitCreate) {
					name = jsonFieldsNameOfHTCLimitCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCLimitCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCLimitCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCLimitUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCLimitUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("vCPUs")
		e.Int32(s.VCPUs)
	}
}

var jsonFieldsNameOfHTCLimitUpdate = [1]string{
	0: "vCPUs",
}

// Decode decodes HTCLimitUpdate from json.
func (s *HTCLimitUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCLimitUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "vCPUs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.VCPUs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vCPUs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCLimitUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCLimitUpdate) {
					name = jsonFieldsNameOfHTCLimitUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCLimitUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCLimitUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCNodePool) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCNodePool) encodeFields(e *jx.Encoder) {
	{
		if s.Autoscaling.Set {
			e.FieldStart("autoscaling")
			s.Autoscaling.Encode(e)
		}
	}
	{
		if s.InstanceType.Set {
			e.FieldStart("instanceType")
			s.InstanceType.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCNodePool = [5]string{
	0: "autoscaling",
	1: "instanceType",
	2: "name",
	3: "status",
	4: "version",
}

// Decode decodes HTCNodePool from json.
func (s *HTCNodePool) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCNodePool to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "autoscaling":
			if err := func() error {
				s.Autoscaling.Reset()
				if err := s.Autoscaling.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoscaling\"")
			}
		case "instanceType":
			if err := func() error {
				s.InstanceType.Reset()
				if err := s.InstanceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceType\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCNodePool")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCNodePool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCNodePool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCProject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCProject) encodeFields(e *jx.Encoder) {
	{
		if s.ContainerRegistry.Set {
			e.FieldStart("containerRegistry")
			s.ContainerRegistry.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.OrganizationCode.Set {
			e.FieldStart("organizationCode")
			s.OrganizationCode.Encode(e)
		}
	}
	{
		e.FieldStart("projectDescription")
		e.Str(s.ProjectDescription)
	}
	{
		if s.ProjectFolderPath.Set {
			e.FieldStart("projectFolderPath")
			s.ProjectFolderPath.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		e.FieldStart("projectName")
		e.Str(s.ProjectName)
	}
	{
		if s.RegionSettings != nil {
			e.FieldStart("regionSettings")
			e.ArrStart()
			for _, elem := range s.RegionSettings {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Regions != nil {
			e.FieldStart("regions")
			e.ArrStart()
			for _, elem := range s.Regions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Repositories != nil {
			e.FieldStart("repositories")
			e.ArrStart()
			for _, elem := range s.Repositories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCProject = [12]string{
	0:  "containerRegistry",
	1:  "createdAt",
	2:  "createdBy",
	3:  "organizationCode",
	4:  "projectDescription",
	5:  "projectFolderPath",
	6:  "projectId",
	7:  "projectName",
	8:  "regionSettings",
	9:  "regions",
	10: "repositories",
	11: "workspaceId",
}

// Decode decodes HTCProject from json.
func (s *HTCProject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCProject to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "containerRegistry":
			if err := func() error {
				s.ContainerRegistry.Reset()
				if err := s.ContainerRegistry.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"containerRegistry\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "organizationCode":
			if err := func() error {
				s.OrganizationCode.Reset()
				if err := s.OrganizationCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationCode\"")
			}
		case "projectDescription":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProjectDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectDescription\"")
			}
		case "projectFolderPath":
			if err := func() error {
				s.ProjectFolderPath.Reset()
				if err := s.ProjectFolderPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectFolderPath\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "projectName":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ProjectName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectName\"")
			}
		case "regionSettings":
			if err := func() error {
				s.RegionSettings = make([]HTCRegionSettings, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTCRegionSettings
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RegionSettings = append(s.RegionSettings, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionSettings\"")
			}
		case "regions":
			if err := func() error {
				s.Regions = make([]RescaleRegion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RescaleRegion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Regions = append(s.Regions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regions\"")
			}
		case "repositories":
			if err := func() error {
				s.Repositories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Repositories = append(s.Repositories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositories\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCProject")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10010000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCProject) {
					name = jsonFieldsNameOfHTCProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCProject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCProject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCProjectDimensions as json.
func (s HTCProjectDimensions) Encode(e *jx.Encoder) {
	unwrapped := []HTCComputeEnvironment(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes HTCProjectDimensions from json.
func (s *HTCProjectDimensions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCProjectDimensions to nil")
	}
	var unwrapped []HTCComputeEnvironment
	if err := func() error {
		unwrapped = make([]HTCComputeEnvironment, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HTCComputeEnvironment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HTCProjectDimensions(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCProjectDimensions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCProjectDimensions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCProjectLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCProjectLimit) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.ModifierRole.Set {
			e.FieldStart("modifierRole")
			s.ModifierRole.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updatedBy")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("vCPUs")
		e.Int32(s.VCPUs)
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCProjectLimit = [9]string{
	0: "createdAt",
	1: "createdBy",
	2: "id",
	3: "modifierRole",
	4: "projectId",
	5: "updatedAt",
	6: "updatedBy",
	7: "vCPUs",
	8: "workspaceId",
}

// Decode decodes HTCProjectLimit from json.
func (s *HTCProjectLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCProjectLimit to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "modifierRole":
			if err := func() error {
				s.ModifierRole.Reset()
				if err := s.ModifierRole.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modifierRole\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "updatedBy":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBy\"")
			}
		case "vCPUs":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int32()
				s.VCPUs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vCPUs\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCProjectLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCProjectLimit) {
					name = jsonFieldsNameOfHTCProjectLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCProjectLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCProjectLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCProjectLimitModifierRole as json.
func (s HTCProjectLimitModifierRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCProjectLimitModifierRole from json.
func (s *HTCProjectLimitModifierRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCProjectLimitModifierRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCProjectLimitModifierRole(v) {
	case HTCProjectLimitModifierRoleWORKSPACEADMIN:
		*s = HTCProjectLimitModifierRoleWORKSPACEADMIN
	case HTCProjectLimitModifierRolePROJECTADMIN:
		*s = HTCProjectLimitModifierRolePROJECTADMIN
	default:
		*s = HTCProjectLimitModifierRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCProjectLimitModifierRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCProjectLimitModifierRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCProjectLimits as json.
func (s HTCProjectLimits) Encode(e *jx.Encoder) {
	unwrapped := []HTCProjectLimit(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes HTCProjectLimits from json.
func (s *HTCProjectLimits) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCProjectLimits to nil")
	}
	var unwrapped []HTCProjectLimit
	if err := func() error {
		unwrapped = make([]HTCProjectLimit, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HTCProjectLimit
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HTCProjectLimits(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCProjectLimits) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCProjectLimits) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCProjectUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCProjectUpdate) encodeFields(e *jx.Encoder) {
	{
		if s.Regions != nil {
			e.FieldStart("regions")
			e.ArrStart()
			for _, elem := range s.Regions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHTCProjectUpdate = [1]string{
	0: "regions",
}

// Decode decodes HTCProjectUpdate from json.
func (s *HTCProjectUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCProjectUpdate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "regions":
			if err := func() error {
				s.Regions = make([]RescaleRegion, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RescaleRegion
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Regions = append(s.Regions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCProjectUpdate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCProjectUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCProjectUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCProjectsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCProjectsResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCProjectsResponse = [2]string{
	0: "items",
	1: "next",
}

// Decode decodes HTCProjectsResponse from json.
func (s *HTCProjectsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCProjectsResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]HTCProject, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTCProject
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCProjectsResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCProjectsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCProjectsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCRegionAdminSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCRegionAdminSettings) encodeFields(e *jx.Encoder) {
	{
		if s.CloudProvider.Set {
			e.FieldStart("cloudProvider")
			s.CloudProvider.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.SupportedArchitectures != nil {
			e.FieldStart("supportedArchitectures")
			e.ArrStart()
			for _, elem := range s.SupportedArchitectures {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updatedBy")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("weight")
			s.Weight.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCRegionAdminSettings = [7]string{
	0: "cloudProvider",
	1: "enabled",
	2: "region",
	3: "supportedArchitectures",
	4: "updatedAt",
	5: "updatedBy",
	6: "weight",
}

// Decode decodes HTCRegionAdminSettings from json.
func (s *HTCRegionAdminSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRegionAdminSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cloudProvider":
			if err := func() error {
				s.CloudProvider.Reset()
				if err := s.CloudProvider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cloudProvider\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "supportedArchitectures":
			if err := func() error {
				s.SupportedArchitectures = make([]Architecture, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Architecture
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedArchitectures = append(s.SupportedArchitectures, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportedArchitectures\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "updatedBy":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBy\"")
			}
		case "weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCRegionAdminSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCRegionAdminSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRegionAdminSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCRegionAdminSettingsRegion as json.
func (s HTCRegionAdminSettingsRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCRegionAdminSettingsRegion from json.
func (s *HTCRegionAdminSettingsRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRegionAdminSettingsRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCRegionAdminSettingsRegion(v) {
	case HTCRegionAdminSettingsRegionAWSAPSOUTHEAST1:
		*s = HTCRegionAdminSettingsRegionAWSAPSOUTHEAST1
	case HTCRegionAdminSettingsRegionAWSCACENTRAL1:
		*s = HTCRegionAdminSettingsRegionAWSCACENTRAL1
	case HTCRegionAdminSettingsRegionAWSEUNORTH1:
		*s = HTCRegionAdminSettingsRegionAWSEUNORTH1
	case HTCRegionAdminSettingsRegionAWSEUCENTRAL1:
		*s = HTCRegionAdminSettingsRegionAWSEUCENTRAL1
	case HTCRegionAdminSettingsRegionAWSEUWEST1:
		*s = HTCRegionAdminSettingsRegionAWSEUWEST1
	case HTCRegionAdminSettingsRegionAWSEUWEST2:
		*s = HTCRegionAdminSettingsRegionAWSEUWEST2
	case HTCRegionAdminSettingsRegionAWSEUWEST3:
		*s = HTCRegionAdminSettingsRegionAWSEUWEST3
	case HTCRegionAdminSettingsRegionAWSSAEAST1:
		*s = HTCRegionAdminSettingsRegionAWSSAEAST1
	case HTCRegionAdminSettingsRegionAWSUSEAST2:
		*s = HTCRegionAdminSettingsRegionAWSUSEAST2
	case HTCRegionAdminSettingsRegionAWSUSWEST2:
		*s = HTCRegionAdminSettingsRegionAWSUSWEST2
	case HTCRegionAdminSettingsRegionAWSUSEAST1:
		*s = HTCRegionAdminSettingsRegionAWSUSEAST1
	case HTCRegionAdminSettingsRegionGCPASIASOUTHEAST1:
		*s = HTCRegionAdminSettingsRegionGCPASIASOUTHEAST1
	case HTCRegionAdminSettingsRegionGCPUSCENTRAL1:
		*s = HTCRegionAdminSettingsRegionGCPUSCENTRAL1
	case HTCRegionAdminSettingsRegionGCPUSEAST1:
		*s = HTCRegionAdminSettingsRegionGCPUSEAST1
	case HTCRegionAdminSettingsRegionGCPUSEAST2:
		*s = HTCRegionAdminSettingsRegionGCPUSEAST2
	case HTCRegionAdminSettingsRegionGCPUSEAST4:
		*s = HTCRegionAdminSettingsRegionGCPUSEAST4
	case HTCRegionAdminSettingsRegionGCPUSWEST1:
		*s = HTCRegionAdminSettingsRegionGCPUSWEST1
	case HTCRegionAdminSettingsRegionGCPUSWEST4:
		*s = HTCRegionAdminSettingsRegionGCPUSWEST4
	case HTCRegionAdminSettingsRegionGCPEUWEST1:
		*s = HTCRegionAdminSettingsRegionGCPEUWEST1
	case HTCRegionAdminSettingsRegionGCPEUWEST2:
		*s = HTCRegionAdminSettingsRegionGCPEUWEST2
	case HTCRegionAdminSettingsRegionGCPEUWEST3:
		*s = HTCRegionAdminSettingsRegionGCPEUWEST3
	case HTCRegionAdminSettingsRegionGCPEUWEST4:
		*s = HTCRegionAdminSettingsRegionGCPEUWEST4
	case HTCRegionAdminSettingsRegionGCPCACENTRAL1:
		*s = HTCRegionAdminSettingsRegionGCPCACENTRAL1
	case HTCRegionAdminSettingsRegionNGCENOCH1:
		*s = HTCRegionAdminSettingsRegionNGCENOCH1
	case HTCRegionAdminSettingsRegionAZUREUSWEST2:
		*s = HTCRegionAdminSettingsRegionAZUREUSWEST2
	case HTCRegionAdminSettingsRegionAZUREUSEAST2:
		*s = HTCRegionAdminSettingsRegionAZUREUSEAST2
	case HTCRegionAdminSettingsRegionAZUREUSSOUTHCENTRAL:
		*s = HTCRegionAdminSettingsRegionAZUREUSSOUTHCENTRAL
	case HTCRegionAdminSettingsRegionAZUREEUNORTH:
		*s = HTCRegionAdminSettingsRegionAZUREEUNORTH
	case HTCRegionAdminSettingsRegionRCICELAND1:
		*s = HTCRegionAdminSettingsRegionRCICELAND1
	case HTCRegionAdminSettingsRegionUNASSIGNED:
		*s = HTCRegionAdminSettingsRegionUNASSIGNED
	default:
		*s = HTCRegionAdminSettingsRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCRegionAdminSettingsRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRegionAdminSettingsRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCRegionComputeSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCRegionComputeSettings) encodeFields(e *jx.Encoder) {
	{
		if s.ComputeRegion.Set {
			e.FieldStart("computeRegion")
			s.ComputeRegion.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCRegionComputeSettings = [1]string{
	0: "computeRegion",
}

// Decode decodes HTCRegionComputeSettings from json.
func (s *HTCRegionComputeSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRegionComputeSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "computeRegion":
			if err := func() error {
				s.ComputeRegion.Reset()
				if err := s.ComputeRegion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computeRegion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCRegionComputeSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCRegionComputeSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRegionComputeSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCRegionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCRegionSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("computeSettings")
		s.ComputeSettings.Encode(e)
	}
	{
		e.FieldStart("storageSettings")
		s.StorageSettings.Encode(e)
	}
}

var jsonFieldsNameOfHTCRegionSettings = [2]string{
	0: "computeSettings",
	1: "storageSettings",
}

// Decode decodes HTCRegionSettings from json.
func (s *HTCRegionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRegionSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "computeSettings":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ComputeSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"computeSettings\"")
			}
		case "storageSettings":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.StorageSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageSettings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCRegionSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCRegionSettings) {
					name = jsonFieldsNameOfHTCRegionSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCRegionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRegionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCRegionStorageSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCRegionStorageSettings) encodeFields(e *jx.Encoder) {
	{
		if s.StorageRegion.Set {
			e.FieldStart("storageRegion")
			s.StorageRegion.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCRegionStorageSettings = [1]string{
	0: "storageRegion",
}

// Decode decodes HTCRegionStorageSettings from json.
func (s *HTCRegionStorageSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRegionStorageSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "storageRegion":
			if err := func() error {
				s.StorageRegion.Reset()
				if err := s.StorageRegion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageRegion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCRegionStorageSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCRegionStorageSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRegionStorageSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCRepository) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCRepository) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		if s.RegistryURI.Set {
			e.FieldStart("registryURI")
			s.RegistryURI.Encode(e)
		}
	}
	{
		if s.RepositoryName.Set {
			e.FieldStart("repositoryName")
			s.RepositoryName.Encode(e)
		}
	}
	{
		if s.SuccessfullyCreated.Set {
			e.FieldStart("successfullyCreated")
			s.SuccessfullyCreated.Encode(e)
		}
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCRepository = [6]string{
	0: "createdBy",
	1: "projectId",
	2: "registryURI",
	3: "repositoryName",
	4: "successfullyCreated",
	5: "workspaceId",
}

// Decode decodes HTCRepository from json.
func (s *HTCRepository) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRepository to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "registryURI":
			if err := func() error {
				s.RegistryURI.Reset()
				if err := s.RegistryURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registryURI\"")
			}
		case "repositoryName":
			if err := func() error {
				s.RepositoryName.Reset()
				if err := s.RepositoryName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"repositoryName\"")
			}
		case "successfullyCreated":
			if err := func() error {
				s.SuccessfullyCreated.Reset()
				if err := s.SuccessfullyCreated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"successfullyCreated\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCRepository")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCRepository) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRepository) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCRequestError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCRequestError) encodeFields(e *jx.Encoder) {
	{
		if s.ErrorDescription.Set {
			e.FieldStart("errorDescription")
			s.ErrorDescription.Encode(e)
		}
	}
	{
		if s.ErrorType.Set {
			e.FieldStart("errorType")
			s.ErrorType.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCRequestError = [3]string{
	0: "errorDescription",
	1: "errorType",
	2: "message",
}

// Decode decodes HTCRequestError from json.
func (s *HTCRequestError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRequestError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errorDescription":
			if err := func() error {
				s.ErrorDescription.Reset()
				if err := s.ErrorDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorDescription\"")
			}
		case "errorType":
			if err := func() error {
				s.ErrorType.Reset()
				if err := s.ErrorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorType\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCRequestError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCRequestError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRequestError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCRetryStrategy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCRetryStrategy) encodeFields(e *jx.Encoder) {
	{
		if s.MaxRetries.Set {
			e.FieldStart("maxRetries")
			s.MaxRetries.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCRetryStrategy = [1]string{
	0: "maxRetries",
}

// Decode decodes HTCRetryStrategy from json.
func (s *HTCRetryStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCRetryStrategy to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxRetries":
			if err := func() error {
				s.MaxRetries.Reset()
				if err := s.MaxRetries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxRetries\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCRetryStrategy")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCRetryStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCRetryStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCTask) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCTask) encodeFields(e *jx.Encoder) {
	{
		if s.ArchivedAt.Set {
			e.FieldStart("archivedAt")
			s.ArchivedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deletedAt")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastActiveAt.Set {
			e.FieldStart("lastActiveAt")
			s.LastActiveAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LifecycleStatus.Set {
			e.FieldStart("lifecycleStatus")
			s.LifecycleStatus.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		e.FieldStart("taskDescription")
		e.Str(s.TaskDescription)
	}
	{
		if s.TaskFolderPath.Set {
			e.FieldStart("taskFolderPath")
			s.TaskFolderPath.Encode(e)
		}
	}
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
	{
		e.FieldStart("taskName")
		e.Str(s.TaskName)
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCTask = [12]string{
	0:  "archivedAt",
	1:  "createdAt",
	2:  "createdBy",
	3:  "deletedAt",
	4:  "lastActiveAt",
	5:  "lifecycleStatus",
	6:  "projectId",
	7:  "taskDescription",
	8:  "taskFolderPath",
	9:  "taskId",
	10: "taskName",
	11: "workspaceId",
}

// Decode decodes HTCTask from json.
func (s *HTCTask) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCTask to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archivedAt":
			if err := func() error {
				s.ArchivedAt.Reset()
				if err := s.ArchivedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archivedAt\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "deletedAt":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "lastActiveAt":
			if err := func() error {
				s.LastActiveAt.Reset()
				if err := s.LastActiveAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastActiveAt\"")
			}
		case "lifecycleStatus":
			if err := func() error {
				s.LifecycleStatus.Reset()
				if err := s.LifecycleStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycleStatus\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "taskDescription":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TaskDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskDescription\"")
			}
		case "taskFolderPath":
			if err := func() error {
				s.TaskFolderPath.Reset()
				if err := s.TaskFolderPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskFolderPath\"")
			}
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "taskName":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskName\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCTask")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCTask) {
					name = jsonFieldsNameOfHTCTask[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCTaskLifecycleStatus as json.
func (s HTCTaskLifecycleStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCTaskLifecycleStatus from json.
func (s *HTCTaskLifecycleStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCTaskLifecycleStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCTaskLifecycleStatus(v) {
	case HTCTaskLifecycleStatusDELETED:
		*s = HTCTaskLifecycleStatusDELETED
	case HTCTaskLifecycleStatusACTIVE:
		*s = HTCTaskLifecycleStatusACTIVE
	case HTCTaskLifecycleStatusARCHIVED:
		*s = HTCTaskLifecycleStatusARCHIVED
	default:
		*s = HTCTaskLifecycleStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCTaskLifecycleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCTaskLifecycleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCTaskUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCTaskUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lifecycleStatus")
		s.LifecycleStatus.Encode(e)
	}
}

var jsonFieldsNameOfHTCTaskUpdate = [1]string{
	0: "lifecycleStatus",
}

// Decode decodes HTCTaskUpdate from json.
func (s *HTCTaskUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCTaskUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lifecycleStatus":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.LifecycleStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycleStatus\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCTaskUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCTaskUpdate) {
					name = jsonFieldsNameOfHTCTaskUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCTaskUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCTaskUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCTaskUpdateLifecycleStatus as json.
func (s HTCTaskUpdateLifecycleStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTCTaskUpdateLifecycleStatus from json.
func (s *HTCTaskUpdateLifecycleStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCTaskUpdateLifecycleStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTCTaskUpdateLifecycleStatus(v) {
	case HTCTaskUpdateLifecycleStatusDELETED:
		*s = HTCTaskUpdateLifecycleStatusDELETED
	case HTCTaskUpdateLifecycleStatusACTIVE:
		*s = HTCTaskUpdateLifecycleStatusACTIVE
	case HTCTaskUpdateLifecycleStatusARCHIVED:
		*s = HTCTaskUpdateLifecycleStatusARCHIVED
	default:
		*s = HTCTaskUpdateLifecycleStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCTaskUpdateLifecycleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCTaskUpdateLifecycleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCTasksResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCTasksResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Next.Set {
			e.FieldStart("next")
			s.Next.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCTasksResponse = [2]string{
	0: "items",
	1: "next",
}

// Decode decodes HTCTasksResponse from json.
func (s *HTCTasksResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCTasksResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]HTCTask, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTCTask
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "next":
			if err := func() error {
				s.Next.Reset()
				if err := s.Next.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"next\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCTasksResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCTasksResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCTasksResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCToken) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCToken) encodeFields(e *jx.Encoder) {
	{
		if s.ExpiresIn.Set {
			e.FieldStart("expiresIn")
			s.ExpiresIn.Encode(e)
		}
	}
	{
		if s.TokenValue.Set {
			e.FieldStart("tokenValue")
			s.TokenValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCToken = [2]string{
	0: "expiresIn",
	1: "tokenValue",
}

// Decode decodes HTCToken from json.
func (s *HTCToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCToken to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expiresIn":
			if err := func() error {
				s.ExpiresIn.Reset()
				if err := s.ExpiresIn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresIn\"")
			}
		case "tokenValue":
			if err := func() error {
				s.TokenValue.Reset()
				if err := s.TokenValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCToken")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCTokenPayload as json.
func (s HTCTokenPayload) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes HTCTokenPayload from json.
func (s *HTCTokenPayload) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCTokenPayload to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HTCTokenPayload(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTCTokenPayload) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCTokenPayload) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HTCWorkspaceLimit) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HTCWorkspaceLimit) encodeFields(e *jx.Encoder) {
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedBy.Set {
			e.FieldStart("updatedBy")
			s.UpdatedBy.Encode(e)
		}
	}
	{
		e.FieldStart("vCPUs")
		e.Int32(s.VCPUs)
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHTCWorkspaceLimit = [6]string{
	0: "createdAt",
	1: "createdBy",
	2: "updatedAt",
	3: "updatedBy",
	4: "vCPUs",
	5: "workspaceId",
}

// Decode decodes HTCWorkspaceLimit from json.
func (s *HTCWorkspaceLimit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTCWorkspaceLimit to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "updatedBy":
			if err := func() error {
				s.UpdatedBy.Reset()
				if err := s.UpdatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedBy\"")
			}
		case "vCPUs":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int32()
				s.VCPUs = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vCPUs\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HTCWorkspaceLimit")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHTCWorkspaceLimit) {
					name = jsonFieldsNameOfHTCWorkspaceLimit[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HTCWorkspaceLimit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTCWorkspaceLimit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.ErrorDescription.Set {
			e.FieldStart("errorDescription")
			s.ErrorDescription.Encode(e)
		}
	}
	{
		if s.ErrorType.Set {
			e.FieldStart("errorType")
			s.ErrorType.Encode(e)
		}
	}
}

var jsonFieldsNameOfHtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound = [2]string{
	0: "errorDescription",
	1: "errorType",
}

// Decode decodes HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound from json.
func (s *HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "errorDescription":
			if err := func() error {
				s.ErrorDescription.Reset()
				if err := s.ErrorDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorDescription\"")
			}
		case "errorType":
			if err := func() error {
				s.ErrorType.Reset()
				if err := s.ErrorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdContainerRegistryImagesImageNameGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON as json.
func (s HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HTCComputeEnvironment(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON from json.
func (s *HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON to nil")
	}
	var unwrapped []HTCComputeEnvironment
	if err := func() error {
		unwrapped = make([]HTCComputeEnvironment, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HTCComputeEnvironment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdDimensionsPutCreatedApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HtcProjectsProjectIdTasksTaskIdDeleteOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HtcProjectsProjectIdTasksTaskIdDeleteOK) encodeFields(e *jx.Encoder) {
	{
		if s.ArchivedAt.Set {
			e.FieldStart("archivedAt")
			s.ArchivedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.CreatedBy.Set {
			e.FieldStart("createdBy")
			s.CreatedBy.Encode(e)
		}
	}
	{
		if s.DeletedAt.Set {
			e.FieldStart("deletedAt")
			s.DeletedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastActiveAt.Set {
			e.FieldStart("lastActiveAt")
			s.LastActiveAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LifecycleStatus.Set {
			e.FieldStart("lifecycleStatus")
			s.LifecycleStatus.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		e.FieldStart("taskDescription")
		e.Str(s.TaskDescription)
	}
	{
		if s.TaskFolderPath.Set {
			e.FieldStart("taskFolderPath")
			s.TaskFolderPath.Encode(e)
		}
	}
	{
		if s.TaskId.Set {
			e.FieldStart("taskId")
			s.TaskId.Encode(e)
		}
	}
	{
		e.FieldStart("taskName")
		e.Str(s.TaskName)
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfHtcProjectsProjectIdTasksTaskIdDeleteOK = [12]string{
	0:  "archivedAt",
	1:  "createdAt",
	2:  "createdBy",
	3:  "deletedAt",
	4:  "lastActiveAt",
	5:  "lifecycleStatus",
	6:  "projectId",
	7:  "taskDescription",
	8:  "taskFolderPath",
	9:  "taskId",
	10: "taskName",
	11: "workspaceId",
}

// Decode decodes HtcProjectsProjectIdTasksTaskIdDeleteOK from json.
func (s *HtcProjectsProjectIdTasksTaskIdDeleteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdTasksTaskIdDeleteOK to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archivedAt":
			if err := func() error {
				s.ArchivedAt.Reset()
				if err := s.ArchivedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archivedAt\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "createdBy":
			if err := func() error {
				s.CreatedBy.Reset()
				if err := s.CreatedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdBy\"")
			}
		case "deletedAt":
			if err := func() error {
				s.DeletedAt.Reset()
				if err := s.DeletedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deletedAt\"")
			}
		case "lastActiveAt":
			if err := func() error {
				s.LastActiveAt.Reset()
				if err := s.LastActiveAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastActiveAt\"")
			}
		case "lifecycleStatus":
			if err := func() error {
				s.LifecycleStatus.Reset()
				if err := s.LifecycleStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifecycleStatus\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "taskDescription":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TaskDescription = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskDescription\"")
			}
		case "taskFolderPath":
			if err := func() error {
				s.TaskFolderPath.Reset()
				if err := s.TaskFolderPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskFolderPath\"")
			}
		case "taskId":
			if err := func() error {
				s.TaskId.Reset()
				if err := s.TaskId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskId\"")
			}
		case "taskName":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TaskName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskName\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HtcProjectsProjectIdTasksTaskIdDeleteOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHtcProjectsProjectIdTasksTaskIdDeleteOK) {
					name = jsonFieldsNameOfHtcProjectsProjectIdTasksTaskIdDeleteOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HtcProjectsProjectIdTasksTaskIdDeleteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdTasksTaskIdDeleteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus as json.
func (s HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus from json.
func (s *HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus(v) {
	case HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatusDELETED:
		*s = HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatusDELETED
	case HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatusACTIVE:
		*s = HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatusACTIVE
	case HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatusARCHIVED:
		*s = HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatusARCHIVED
	default:
		*s = HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON as json.
func (s HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON from json.
func (s *HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON as json.
func (s HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []string(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON from json.
func (s *HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdTasksTaskIdGroupsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON as json.
func (s HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON from json.
func (s *HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON as json.
func (s HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON from json.
func (s *HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcStorageGetOKApplicationJSON as json.
func (s HtcStorageGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []RegionStorageOption(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes HtcStorageGetOKApplicationJSON from json.
func (s *HtcStorageGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcStorageGetOKApplicationJSON to nil")
	}
	var unwrapped []RegionStorageOption
	if err := func() error {
		unwrapped = make([]RegionStorageOption, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem RegionStorageOption
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HtcStorageGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcStorageGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcStorageGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON as json.
func (s HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []HTCComputeEnvironment(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON from json.
func (s *HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON to nil")
	}
	var unwrapped []HTCComputeEnvironment
	if err := func() error {
		unwrapped = make([]HTCComputeEnvironment, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem HTCComputeEnvironment
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HtcWorkspacesWorkspaceIdDimensionsGetOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InstanceLabels) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstanceLabels) encodeFields(e *jx.Encoder) {
	{
		if s.AccountId.Set {
			e.FieldStart("accountId")
			s.AccountId.Encode(e)
		}
	}
	{
		if s.Csp.Set {
			e.FieldStart("csp")
			s.Csp.Encode(e)
		}
	}
	{
		if s.InstanceArchitecture.Set {
			e.FieldStart("instanceArchitecture")
			s.InstanceArchitecture.Encode(e)
		}
	}
	{
		if s.InstanceType.Set {
			e.FieldStart("instanceType")
			s.InstanceType.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstanceLabels = [6]string{
	0: "accountId",
	1: "csp",
	2: "instanceArchitecture",
	3: "instanceType",
	4: "priority",
	5: "region",
}

// Decode decodes InstanceLabels from json.
func (s *InstanceLabels) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstanceLabels to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accountId":
			if err := func() error {
				s.AccountId.Reset()
				if err := s.AccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accountId\"")
			}
		case "csp":
			if err := func() error {
				s.Csp.Reset()
				if err := s.Csp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"csp\"")
			}
		case "instanceArchitecture":
			if err := func() error {
				s.InstanceArchitecture.Reset()
				if err := s.InstanceArchitecture.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceArchitecture\"")
			}
		case "instanceType":
			if err := func() error {
				s.InstanceType.Reset()
				if err := s.InstanceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceType\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstanceLabels")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstanceLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstanceLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Instant as json.
func (s Instant) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes Instant from json.
func (s *Instant) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Instant to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Instant(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Instant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Instant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JobExecutionEnvironment) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JobExecutionEnvironment) encodeFields(e *jx.Encoder) {
	{
		if s.Architecture.Set {
			e.FieldStart("architecture")
			s.Architecture.Encode(e)
		}
	}
	{
		if s.InstanceId.Set {
			e.FieldStart("instanceId")
			s.InstanceId.Encode(e)
		}
	}
	{
		if s.InstanceType.Set {
			e.FieldStart("instanceType")
			s.InstanceType.Encode(e)
		}
	}
}

var jsonFieldsNameOfJobExecutionEnvironment = [3]string{
	0: "architecture",
	1: "instanceId",
	2: "instanceType",
}

// Decode decodes JobExecutionEnvironment from json.
func (s *JobExecutionEnvironment) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobExecutionEnvironment to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "architecture":
			if err := func() error {
				s.Architecture.Reset()
				if err := s.Architecture.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"architecture\"")
			}
		case "instanceId":
			if err := func() error {
				s.InstanceId.Reset()
				if err := s.InstanceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceId\"")
			}
		case "instanceType":
			if err := func() error {
				s.InstanceType.Reset()
				if err := s.InstanceType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instanceType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JobExecutionEnvironment")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JobExecutionEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobExecutionEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JobPriority as json.
func (s JobPriority) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JobPriority from json.
func (s *JobPriority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JobPriority to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JobPriority(v) {
	case JobPriorityONDEMANDPRIORITY:
		*s = JobPriorityONDEMANDPRIORITY
	case JobPriorityONDEMANDECONOMY:
		*s = JobPriorityONDEMANDECONOMY
	default:
		*s = JobPriority(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JobPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JobPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JsonWebKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JsonWebKey) encodeFields(e *jx.Encoder) {
	{
		if s.Algorithm.Set {
			e.FieldStart("algorithm")
			s.Algorithm.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.KeyId.Set {
			e.FieldStart("keyId")
			s.KeyId.Encode(e)
		}
	}
	{
		if s.KeyOps != nil {
			e.FieldStart("keyOps")
			e.ArrStart()
			for _, elem := range s.KeyOps {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.KeyType.Set {
			e.FieldStart("keyType")
			s.KeyType.Encode(e)
		}
	}
	{
		if s.OtherParameters.Set {
			e.FieldStart("otherParameters")
			s.OtherParameters.Encode(e)
		}
	}
	{
		if s.PublicKey.Set {
			e.FieldStart("publicKey")
			s.PublicKey.Encode(e)
		}
	}
	{
		if s.Use.Set {
			e.FieldStart("use")
			s.Use.Encode(e)
		}
	}
}

var jsonFieldsNameOfJsonWebKey = [8]string{
	0: "algorithm",
	1: "key",
	2: "keyId",
	3: "keyOps",
	4: "keyType",
	5: "otherParameters",
	6: "publicKey",
	7: "use",
}

// Decode decodes JsonWebKey from json.
func (s *JsonWebKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonWebKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "algorithm":
			if err := func() error {
				s.Algorithm.Reset()
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "keyId":
			if err := func() error {
				s.KeyId.Reset()
				if err := s.KeyId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyId\"")
			}
		case "keyOps":
			if err := func() error {
				s.KeyOps = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.KeyOps = append(s.KeyOps, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyOps\"")
			}
		case "keyType":
			if err := func() error {
				s.KeyType.Reset()
				if err := s.KeyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keyType\"")
			}
		case "otherParameters":
			if err := func() error {
				s.OtherParameters.Reset()
				if err := s.OtherParameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otherParameters\"")
			}
		case "publicKey":
			if err := func() error {
				s.PublicKey.Reset()
				if err := s.PublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKey\"")
			}
		case "use":
			if err := func() error {
				s.Use.Reset()
				if err := s.Use.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"use\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonWebKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JsonWebKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonWebKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s JsonWebKeyOtherParameters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s JsonWebKeyOtherParameters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes JsonWebKeyOtherParameters from json.
func (s *JsonWebKeyOtherParameters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonWebKeyOtherParameters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonWebKeyOtherParameters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JsonWebKeyOtherParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonWebKeyOtherParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *JsonWebKeySet) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *JsonWebKeySet) encodeFields(e *jx.Encoder) {
	{
		if s.JsonWebKeys != nil {
			e.FieldStart("jsonWebKeys")
			e.ArrStart()
			for _, elem := range s.JsonWebKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Keys != nil {
			e.FieldStart("keys")
			e.ArrStart()
			for _, elem := range s.Keys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfJsonWebKeySet = [2]string{
	0: "jsonWebKeys",
	1: "keys",
}

// Decode decodes JsonWebKeySet from json.
func (s *JsonWebKeySet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JsonWebKeySet to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "jsonWebKeys":
			if err := func() error {
				s.JsonWebKeys = make([]JsonWebKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JsonWebKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.JsonWebKeys = append(s.JsonWebKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jsonWebKeys\"")
			}
		case "keys":
			if err := func() error {
				s.Keys = make([]JsonWebKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JsonWebKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Keys = append(s.Keys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode JsonWebKeySet")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *JsonWebKeySet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JsonWebKeySet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Key) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Key) encodeFields(e *jx.Encoder) {
	{
		if s.Algorithm.Set {
			e.FieldStart("algorithm")
			s.Algorithm.Encode(e)
		}
	}
	{
		if s.Encoded.Set {
			e.FieldStart("encoded")
			s.Encoded.Encode(e)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
}

var jsonFieldsNameOfKey = [3]string{
	0: "algorithm",
	1: "encoded",
	2: "format",
}

// Decode decodes Key from json.
func (s *Key) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Key to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "algorithm":
			if err := func() error {
				s.Algorithm.Reset()
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "encoded":
			if err := func() error {
				s.Encoded.Reset()
				if err := s.Encoded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoded\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Key")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Key) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Key) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModifierRole as json.
func (s ModifierRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ModifierRole from json.
func (s *ModifierRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifierRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ModifierRole(v) {
	case ModifierRoleWORKSPACEADMIN:
		*s = ModifierRoleWORKSPACEADMIN
	case ModifierRolePROJECTADMIN:
		*s = ModifierRolePROJECTADMIN
	default:
		*s = ModifierRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModifierRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifierRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NameValuePair) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NameValuePair) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfNameValuePair = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes NameValuePair from json.
func (s *NameValuePair) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NameValuePair to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NameValuePair")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNameValuePair) {
					name = jsonFieldsNameOfNameValuePair[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NameValuePair) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NameValuePair) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2ErrorResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2ErrorResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.ErrorDescription.Set {
			e.FieldStart("errorDescription")
			s.ErrorDescription.Encode(e)
		}
	}
}

var jsonFieldsNameOfOAuth2ErrorResponse = [2]string{
	0: "error",
	1: "errorDescription",
}

// Decode decodes OAuth2ErrorResponse from json.
func (s *OAuth2ErrorResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2ErrorResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "errorDescription":
			if err := func() error {
				s.ErrorDescription.Reset()
				if err := s.ErrorDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2ErrorResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2ErrorResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2ErrorResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2Token) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2Token) encodeFields(e *jx.Encoder) {
	{
		if s.AccessToken.Set {
			e.FieldStart("access_token")
			s.AccessToken.Encode(e)
		}
	}
	{
		if s.ExpiresIn.Set {
			e.FieldStart("expires_in")
			s.ExpiresIn.Encode(e)
		}
	}
	{
		if s.TokenType.Set {
			e.FieldStart("token_type")
			s.TokenType.Encode(e)
		}
	}
}

var jsonFieldsNameOfOAuth2Token = [3]string{
	0: "access_token",
	1: "expires_in",
	2: "token_type",
}

// Decode decodes OAuth2Token from json.
func (s *OAuth2Token) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2Token to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "access_token":
			if err := func() error {
				s.AccessToken.Reset()
				if err := s.AccessToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"access_token\"")
			}
		case "expires_in":
			if err := func() error {
				s.ExpiresIn.Reset()
				if err := s.ExpiresIn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expires_in\"")
			}
		case "token_type":
			if err := func() error {
				s.TokenType.Reset()
				if err := s.TokenType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2Token")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2Token) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2Token) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Architecture as json.
func (o OptArchitecture) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Architecture from json.
func (o *OptArchitecture) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptArchitecture to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptArchitecture) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptArchitecture) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoscalingConfig as json.
func (o OptAutoscalingConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes AutoscalingConfig from json.
func (o *OptAutoscalingConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAutoscalingConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAutoscalingConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAutoscalingConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutoscalingProfile as json.
func (o OptAutoscalingProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AutoscalingProfile from json.
func (o *OptAutoscalingProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAutoscalingProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAutoscalingProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAutoscalingProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CloudProvider as json.
func (o OptCloudProvider) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CloudProvider from json.
func (o *OptCloudProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCloudProvider to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCloudProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCloudProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ContainerDetails as json.
func (o OptContainerDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ContainerDetails from json.
func (o *OptContainerDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptContainerDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptContainerDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptContainerDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes ExperimentalFields as json.
func (o OptExperimentalFields) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ExperimentalFields from json.
func (o *OptExperimentalFields) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptExperimentalFields to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptExperimentalFields) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptExperimentalFields) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FeatureFlagsResult as json.
func (o OptFeatureFlagsResult) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FeatureFlagsResult from json.
func (o *OptFeatureFlagsResult) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFeatureFlagsResult to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFeatureFlagsResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFeatureFlagsResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentComputeScalingPolicy as json.
func (o OptHTCComputeEnvironmentComputeScalingPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCComputeEnvironmentComputeScalingPolicy from json.
func (o *OptHTCComputeEnvironmentComputeScalingPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCComputeEnvironmentComputeScalingPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCComputeEnvironmentComputeScalingPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCComputeEnvironmentComputeScalingPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentDerived as json.
func (o OptHTCComputeEnvironmentDerived) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCComputeEnvironmentDerived from json.
func (o *OptHTCComputeEnvironmentDerived) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCComputeEnvironmentDerived to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCComputeEnvironmentDerived) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCComputeEnvironmentDerived) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentDerivedArchitecture as json.
func (o OptHTCComputeEnvironmentDerivedArchitecture) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCComputeEnvironmentDerivedArchitecture from json.
func (o *OptHTCComputeEnvironmentDerivedArchitecture) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCComputeEnvironmentDerivedArchitecture to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCComputeEnvironmentDerivedArchitecture) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCComputeEnvironmentDerivedArchitecture) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentPriority as json.
func (o OptHTCComputeEnvironmentPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCComputeEnvironmentPriority from json.
func (o *OptHTCComputeEnvironmentPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCComputeEnvironmentPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCComputeEnvironmentPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCComputeEnvironmentPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCComputeEnvironmentRegion as json.
func (o OptHTCComputeEnvironmentRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCComputeEnvironmentRegion from json.
func (o *OptHTCComputeEnvironmentRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCComputeEnvironmentRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCComputeEnvironmentRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCComputeEnvironmentRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCJobDefinitionTags as json.
func (o OptHTCJobDefinitionTags) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCJobDefinitionTags from json.
func (o *OptHTCJobDefinitionTags) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCJobDefinitionTags to nil")
	}
	o.Set = true
	o.Value = make(HTCJobDefinitionTags)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCJobDefinitionTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCJobDefinitionTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCLimitCreate as json.
func (o OptHTCLimitCreate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCLimitCreate from json.
func (o *OptHTCLimitCreate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCLimitCreate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCLimitCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCLimitCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCLimitUpdate as json.
func (o OptHTCLimitUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCLimitUpdate from json.
func (o *OptHTCLimitUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCLimitUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCLimitUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCLimitUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCProject as json.
func (o OptHTCProject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCProject from json.
func (o *OptHTCProject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCProject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCProject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCProject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCProjectLimitModifierRole as json.
func (o OptHTCProjectLimitModifierRole) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCProjectLimitModifierRole from json.
func (o *OptHTCProjectLimitModifierRole) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCProjectLimitModifierRole to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCProjectLimitModifierRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCProjectLimitModifierRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCProjectUpdate as json.
func (o OptHTCProjectUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCProjectUpdate from json.
func (o *OptHTCProjectUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCProjectUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCProjectUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCProjectUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCRegionAdminSettingsRegion as json.
func (o OptHTCRegionAdminSettingsRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCRegionAdminSettingsRegion from json.
func (o *OptHTCRegionAdminSettingsRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCRegionAdminSettingsRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCRegionAdminSettingsRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCRegionAdminSettingsRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCRetryStrategy as json.
func (o OptHTCRetryStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCRetryStrategy from json.
func (o *OptHTCRetryStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCRetryStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCRetryStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCRetryStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCTask as json.
func (o OptHTCTask) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCTask from json.
func (o *OptHTCTask) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCTask to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCTask) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCTask) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCTaskLifecycleStatus as json.
func (o OptHTCTaskLifecycleStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCTaskLifecycleStatus from json.
func (o *OptHTCTaskLifecycleStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCTaskLifecycleStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCTaskLifecycleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCTaskLifecycleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTCTaskUpdate as json.
func (o OptHTCTaskUpdate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HTCTaskUpdate from json.
func (o *OptHTCTaskUpdate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTCTaskUpdate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTCTaskUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTCTaskUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus as json.
func (o OptHtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus from json.
func (o *OptHtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHtcProjectsProjectIdTasksTaskIdDeleteOKLifecycleStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes InstanceLabels as json.
func (o OptInstanceLabels) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes InstanceLabels from json.
func (o *OptInstanceLabels) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstanceLabels to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstanceLabels) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstanceLabels) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Instant as json.
func (o OptInstant) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Instant from json.
func (o *OptInstant) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInstant to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInstant) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInstant) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JobExecutionEnvironment as json.
func (o OptJobExecutionEnvironment) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JobExecutionEnvironment from json.
func (o *OptJobExecutionEnvironment) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJobExecutionEnvironment to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJobExecutionEnvironment) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJobExecutionEnvironment) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JobPriority as json.
func (o OptJobPriority) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes JobPriority from json.
func (o *OptJobPriority) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJobPriority to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJobPriority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJobPriority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JsonWebKeyOtherParameters as json.
func (o OptJsonWebKeyOtherParameters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JsonWebKeyOtherParameters from json.
func (o *OptJsonWebKeyOtherParameters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJsonWebKeyOtherParameters to nil")
	}
	o.Set = true
	o.Value = make(JsonWebKeyOtherParameters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJsonWebKeyOtherParameters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJsonWebKeyOtherParameters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Key as json.
func (o OptKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Key from json.
func (o *OptKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptNilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptNilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes HTCJobFailureCode as json.
func (o OptNilHTCJobFailureCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTCJobFailureCode from json.
func (o *OptNilHTCJobFailureCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilHTCJobFailureCode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v HTCJobFailureCode
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilHTCJobFailureCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilHTCJobFailureCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Organization as json.
func (o OptOrganization) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Organization from json.
func (o *OptOrganization) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOrganization to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOrganization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOrganization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PresignedPutUrlResponseURL as json.
func (o OptPresignedPutUrlResponseURL) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PresignedPutUrlResponseURL from json.
func (o *OptPresignedPutUrlResponseURL) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPresignedPutUrlResponseURL to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPresignedPutUrlResponseURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPresignedPutUrlResponseURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PublicKey as json.
func (o OptPublicKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PublicKey from json.
func (o *OptPublicKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPublicKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPublicKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPublicKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RegionalStoreCredentials as json.
func (o OptRegionalStoreCredentials) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RegionalStoreCredentials from json.
func (o *OptRegionalStoreCredentials) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRegionalStoreCredentials to nil")
	}
	o.Set = true
	o.Value = make(RegionalStoreCredentials)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRegionalStoreCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRegionalStoreCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RescaleJobStatus as json.
func (o OptRescaleJobStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RescaleJobStatus from json.
func (o *OptRescaleJobStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRescaleJobStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRescaleJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRescaleJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RescaleRegion as json.
func (o OptRescaleRegion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RescaleRegion from json.
func (o *OptRescaleRegion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRescaleRegion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRescaleRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRescaleRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RescaleUser as json.
func (o OptRescaleUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RescaleUser from json.
func (o *OptRescaleUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRescaleUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRescaleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRescaleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Status as json.
func (o OptStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Status from json.
func (o *OptStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Status1 as json.
func (o OptStatus1) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes Status1 from json.
func (o *OptStatus1) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStatus1 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStatus1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStatus1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageAccessTokenCredentials as json.
func (o OptStorageAccessTokenCredentials) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StorageAccessTokenCredentials from json.
func (o *OptStorageAccessTokenCredentials) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStorageAccessTokenCredentials to nil")
	}
	o.Set = true
	o.Value = make(StorageAccessTokenCredentials)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStorageAccessTokenCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStorageAccessTokenCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TaskRetentionPolicy as json.
func (o OptTaskRetentionPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TaskRetentionPolicy from json.
func (o *OptTaskRetentionPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTaskRetentionPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTaskRetentionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTaskRetentionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Workspace as json.
func (o OptWorkspace) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Workspace from json.
func (o *OptWorkspace) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkspace to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkspace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkspace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes WorkspaceTaskRetentionPolicy as json.
func (o OptWorkspaceTaskRetentionPolicy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes WorkspaceTaskRetentionPolicy from json.
func (o *OptWorkspaceTaskRetentionPolicy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptWorkspaceTaskRetentionPolicy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptWorkspaceTaskRetentionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptWorkspaceTaskRetentionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Organization) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Organization) encodeFields(e *jx.Encoder) {
	{
		if s.CanViewOrganizationJobs.Set {
			e.FieldStart("canViewOrganizationJobs")
			s.CanViewOrganizationJobs.Encode(e)
		}
	}
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
}

var jsonFieldsNameOfOrganization = [2]string{
	0: "canViewOrganizationJobs",
	1: "code",
}

// Decode decodes Organization from json.
func (s *Organization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Organization to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "canViewOrganizationJobs":
			if err := func() error {
				s.CanViewOrganizationJobs.Reset()
				if err := s.CanViewOrganizationJobs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"canViewOrganizationJobs\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Organization")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Organization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Organization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PresignedPutUrlResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PresignedPutUrlResponse) encodeFields(e *jx.Encoder) {
	{
		if s.Expiration.Set {
			e.FieldStart("expiration")
			s.Expiration.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.StorageName.Set {
			e.FieldStart("storageName")
			s.StorageName.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfPresignedPutUrlResponse = [4]string{
	0: "expiration",
	1: "region",
	2: "storageName",
	3: "url",
}

// Decode decodes PresignedPutUrlResponse from json.
func (s *PresignedPutUrlResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresignedPutUrlResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "expiration":
			if err := func() error {
				s.Expiration.Reset()
				if err := s.Expiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "storageName":
			if err := func() error {
				s.StorageName.Reset()
				if err := s.StorageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageName\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PresignedPutUrlResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PresignedPutUrlResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresignedPutUrlResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PresignedPutUrlResponseURL) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PresignedPutUrlResponseURL) encodeFields(e *jx.Encoder) {
	{
		if s.Authority.Set {
			e.FieldStart("authority")
			s.Authority.Encode(e)
		}
	}
	{
		if len(s.Content) != 0 {
			e.FieldStart("content")
			e.Raw(s.Content)
		}
	}
	{
		if s.DefaultPort.Set {
			e.FieldStart("defaultPort")
			s.DefaultPort.Encode(e)
		}
	}
	{
		if s.File.Set {
			e.FieldStart("file")
			s.File.Encode(e)
		}
	}
	{
		if s.HashCode.Set {
			e.FieldStart("hashCode")
			s.HashCode.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.Ref.Set {
			e.FieldStart("ref")
			s.Ref.Encode(e)
		}
	}
	{
		if s.SerializedHashCode.Set {
			e.FieldStart("serializedHashCode")
			s.SerializedHashCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPresignedPutUrlResponseURL = [10]string{
	0: "authority",
	1: "content",
	2: "defaultPort",
	3: "file",
	4: "hashCode",
	5: "host",
	6: "port",
	7: "protocol",
	8: "ref",
	9: "serializedHashCode",
}

// Decode decodes PresignedPutUrlResponseURL from json.
func (s *PresignedPutUrlResponseURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PresignedPutUrlResponseURL to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authority":
			if err := func() error {
				s.Authority.Reset()
				if err := s.Authority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authority\"")
			}
		case "content":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Content = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "defaultPort":
			if err := func() error {
				s.DefaultPort.Reset()
				if err := s.DefaultPort.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultPort\"")
			}
		case "file":
			if err := func() error {
				s.File.Reset()
				if err := s.File.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file\"")
			}
		case "hashCode":
			if err := func() error {
				s.HashCode.Reset()
				if err := s.HashCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashCode\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "serializedHashCode":
			if err := func() error {
				s.SerializedHashCode.Reset()
				if err := s.SerializedHashCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serializedHashCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PresignedPutUrlResponseURL")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PresignedPutUrlResponseURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PresignedPutUrlResponseURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PublicKey) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PublicKey) encodeFields(e *jx.Encoder) {
	{
		if s.Algorithm.Set {
			e.FieldStart("algorithm")
			s.Algorithm.Encode(e)
		}
	}
	{
		if s.Encoded.Set {
			e.FieldStart("encoded")
			s.Encoded.Encode(e)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
}

var jsonFieldsNameOfPublicKey = [3]string{
	0: "algorithm",
	1: "encoded",
	2: "format",
}

// Decode decodes PublicKey from json.
func (s *PublicKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PublicKey to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "algorithm":
			if err := func() error {
				s.Algorithm.Reset()
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "encoded":
			if err := func() error {
				s.Encoded.Reset()
				if err := s.Encoded.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoded\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PublicKey")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PublicKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PublicKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegionStorageOption) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegionStorageOption) encodeFields(e *jx.Encoder) {
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.StorageName.Set {
			e.FieldStart("storageName")
			s.StorageName.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegionStorageOption = [3]string{
	0: "provider",
	1: "region",
	2: "storageName",
}

// Decode decodes RegionStorageOption from json.
func (s *RegionStorageOption) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegionStorageOption to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "storageName":
			if err := func() error {
				s.StorageName.Reset()
				if err := s.StorageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegionStorageOption")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegionStorageOption) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegionStorageOption) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegionalStorageResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegionalStorageResponse) encodeFields(e *jx.Encoder) {
	{
		if s.RegionalStores != nil {
			e.FieldStart("regionalStores")
			e.ArrStart()
			for _, elem := range s.RegionalStores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RescaleRegion.Set {
			e.FieldStart("rescaleRegion")
			s.RescaleRegion.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegionalStorageResponse = [2]string{
	0: "regionalStores",
	1: "rescaleRegion",
}

// Decode decodes RegionalStorageResponse from json.
func (s *RegionalStorageResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegionalStorageResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "regionalStores":
			if err := func() error {
				s.RegionalStores = make([]RegionalStore, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RegionalStore
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RegionalStores = append(s.RegionalStores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionalStores\"")
			}
		case "rescaleRegion":
			if err := func() error {
				s.RescaleRegion.Reset()
				if err := s.RescaleRegion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rescaleRegion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegionalStorageResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegionalStorageResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegionalStorageResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegionalStore) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegionalStore) encodeFields(e *jx.Encoder) {
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
	{
		if s.ProjectPath.Set {
			e.FieldStart("projectPath")
			s.ProjectPath.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.TaskPath.Set {
			e.FieldStart("taskPath")
			s.TaskPath.Encode(e)
		}
	}
}

var jsonFieldsNameOfRegionalStore = [5]string{
	0: "credentials",
	1: "projectPath",
	2: "provider",
	3: "region",
	4: "taskPath",
}

// Decode decodes RegionalStore from json.
func (s *RegionalStore) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegionalStore to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		case "projectPath":
			if err := func() error {
				s.ProjectPath.Reset()
				if err := s.ProjectPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectPath\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "taskPath":
			if err := func() error {
				s.TaskPath.Reset()
				if err := s.TaskPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"taskPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegionalStore")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegionalStore) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegionalStore) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RegionalStoreCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RegionalStoreCredentials) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes RegionalStoreCredentials from json.
func (s *RegionalStoreCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegionalStoreCredentials to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegionalStoreCredentials")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RegionalStoreCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegionalStoreCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RescaleFlag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RescaleFlag) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfRescaleFlag = [2]string{
	0: "name",
	1: "value",
}

// Decode decodes RescaleFlag from json.
func (s *RescaleFlag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RescaleFlag to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RescaleFlag")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RescaleFlag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RescaleFlag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RescaleJobStatus as json.
func (s RescaleJobStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RescaleJobStatus from json.
func (s *RescaleJobStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RescaleJobStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RescaleJobStatus(v) {
	case RescaleJobStatusSUBMITTEDTORESCALE:
		*s = RescaleJobStatusSUBMITTEDTORESCALE
	case RescaleJobStatusSUBMITTEDTOPROVIDER:
		*s = RescaleJobStatusSUBMITTEDTOPROVIDER
	case RescaleJobStatusRUNNABLE:
		*s = RescaleJobStatusRUNNABLE
	case RescaleJobStatusSTARTING:
		*s = RescaleJobStatusSTARTING
	case RescaleJobStatusRUNNING:
		*s = RescaleJobStatusRUNNING
	case RescaleJobStatusSUCCEEDED:
		*s = RescaleJobStatusSUCCEEDED
	case RescaleJobStatusFAILED:
		*s = RescaleJobStatusFAILED
	case RescaleJobStatusPODSUCCEEDED:
		*s = RescaleJobStatusPODSUCCEEDED
	case RescaleJobStatusPODFAILED:
		*s = RescaleJobStatusPODFAILED
	default:
		*s = RescaleJobStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RescaleJobStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RescaleJobStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RescaleRegion as json.
func (s RescaleRegion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RescaleRegion from json.
func (s *RescaleRegion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RescaleRegion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RescaleRegion(v) {
	case RescaleRegionAWSAPSOUTHEAST1:
		*s = RescaleRegionAWSAPSOUTHEAST1
	case RescaleRegionAWSCACENTRAL1:
		*s = RescaleRegionAWSCACENTRAL1
	case RescaleRegionAWSEUNORTH1:
		*s = RescaleRegionAWSEUNORTH1
	case RescaleRegionAWSEUCENTRAL1:
		*s = RescaleRegionAWSEUCENTRAL1
	case RescaleRegionAWSEUWEST1:
		*s = RescaleRegionAWSEUWEST1
	case RescaleRegionAWSEUWEST2:
		*s = RescaleRegionAWSEUWEST2
	case RescaleRegionAWSEUWEST3:
		*s = RescaleRegionAWSEUWEST3
	case RescaleRegionAWSSAEAST1:
		*s = RescaleRegionAWSSAEAST1
	case RescaleRegionAWSUSEAST2:
		*s = RescaleRegionAWSUSEAST2
	case RescaleRegionAWSUSWEST2:
		*s = RescaleRegionAWSUSWEST2
	case RescaleRegionAWSUSEAST1:
		*s = RescaleRegionAWSUSEAST1
	case RescaleRegionGCPASIASOUTHEAST1:
		*s = RescaleRegionGCPASIASOUTHEAST1
	case RescaleRegionGCPUSCENTRAL1:
		*s = RescaleRegionGCPUSCENTRAL1
	case RescaleRegionGCPUSEAST1:
		*s = RescaleRegionGCPUSEAST1
	case RescaleRegionGCPUSEAST2:
		*s = RescaleRegionGCPUSEAST2
	case RescaleRegionGCPUSEAST4:
		*s = RescaleRegionGCPUSEAST4
	case RescaleRegionGCPUSWEST1:
		*s = RescaleRegionGCPUSWEST1
	case RescaleRegionGCPUSWEST4:
		*s = RescaleRegionGCPUSWEST4
	case RescaleRegionGCPEUWEST1:
		*s = RescaleRegionGCPEUWEST1
	case RescaleRegionGCPEUWEST2:
		*s = RescaleRegionGCPEUWEST2
	case RescaleRegionGCPEUWEST3:
		*s = RescaleRegionGCPEUWEST3
	case RescaleRegionGCPEUWEST4:
		*s = RescaleRegionGCPEUWEST4
	case RescaleRegionGCPCACENTRAL1:
		*s = RescaleRegionGCPCACENTRAL1
	case RescaleRegionNGCENOCH1:
		*s = RescaleRegionNGCENOCH1
	case RescaleRegionAZUREUSWEST2:
		*s = RescaleRegionAZUREUSWEST2
	case RescaleRegionAZUREUSEAST2:
		*s = RescaleRegionAZUREUSEAST2
	case RescaleRegionAZUREUSSOUTHCENTRAL:
		*s = RescaleRegionAZUREUSSOUTHCENTRAL
	case RescaleRegionAZUREEUNORTH:
		*s = RescaleRegionAZUREEUNORTH
	case RescaleRegionRCICELAND1:
		*s = RescaleRegionRCICELAND1
	case RescaleRegionUNASSIGNED:
		*s = RescaleRegionUNASSIGNED
	default:
		*s = RescaleRegion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RescaleRegion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RescaleRegion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RescaleUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RescaleUser) encodeFields(e *jx.Encoder) {
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.FullName.Set {
			e.FieldStart("fullName")
			s.FullName.Encode(e)
		}
	}
	{
		if s.IsOrganizationAdmin.Set {
			e.FieldStart("isOrganizationAdmin")
			s.IsOrganizationAdmin.Encode(e)
		}
	}
	{
		if s.IsRescaleAdmin.Set {
			e.FieldStart("isRescaleAdmin")
			s.IsRescaleAdmin.Encode(e)
		}
	}
	{
		if s.IsSuperuser.Set {
			e.FieldStart("isSuperuser")
			s.IsSuperuser.Encode(e)
		}
	}
	{
		if s.IsWorkspaceAdmin.Set {
			e.FieldStart("isWorkspaceAdmin")
			s.IsWorkspaceAdmin.Encode(e)
		}
	}
	{
		if s.Organization.Set {
			e.FieldStart("organization")
			s.Organization.Encode(e)
		}
	}
	{
		if s.OrganizationAdmin.Set {
			e.FieldStart("organizationAdmin")
			s.OrganizationAdmin.Encode(e)
		}
	}
	{
		if s.RescaleAdmin.Set {
			e.FieldStart("rescaleAdmin")
			s.RescaleAdmin.Encode(e)
		}
	}
	{
		if s.Superuser.Set {
			e.FieldStart("superuser")
			s.Superuser.Encode(e)
		}
	}
	{
		if s.UserId.Set {
			e.FieldStart("userId")
			s.UserId.Encode(e)
		}
	}
	{
		if s.Workspace.Set {
			e.FieldStart("workspace")
			s.Workspace.Encode(e)
		}
	}
	{
		if s.WorkspaceAdmin.Set {
			e.FieldStart("workspaceAdmin")
			s.WorkspaceAdmin.Encode(e)
		}
	}
}

var jsonFieldsNameOfRescaleUser = [13]string{
	0:  "email",
	1:  "fullName",
	2:  "isOrganizationAdmin",
	3:  "isRescaleAdmin",
	4:  "isSuperuser",
	5:  "isWorkspaceAdmin",
	6:  "organization",
	7:  "organizationAdmin",
	8:  "rescaleAdmin",
	9:  "superuser",
	10: "userId",
	11: "workspace",
	12: "workspaceAdmin",
}

// Decode decodes RescaleUser from json.
func (s *RescaleUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RescaleUser to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "fullName":
			if err := func() error {
				s.FullName.Reset()
				if err := s.FullName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fullName\"")
			}
		case "isOrganizationAdmin":
			if err := func() error {
				s.IsOrganizationAdmin.Reset()
				if err := s.IsOrganizationAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOrganizationAdmin\"")
			}
		case "isRescaleAdmin":
			if err := func() error {
				s.IsRescaleAdmin.Reset()
				if err := s.IsRescaleAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRescaleAdmin\"")
			}
		case "isSuperuser":
			if err := func() error {
				s.IsSuperuser.Reset()
				if err := s.IsSuperuser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isSuperuser\"")
			}
		case "isWorkspaceAdmin":
			if err := func() error {
				s.IsWorkspaceAdmin.Reset()
				if err := s.IsWorkspaceAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isWorkspaceAdmin\"")
			}
		case "organization":
			if err := func() error {
				s.Organization.Reset()
				if err := s.Organization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organization\"")
			}
		case "organizationAdmin":
			if err := func() error {
				s.OrganizationAdmin.Reset()
				if err := s.OrganizationAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"organizationAdmin\"")
			}
		case "rescaleAdmin":
			if err := func() error {
				s.RescaleAdmin.Reset()
				if err := s.RescaleAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rescaleAdmin\"")
			}
		case "superuser":
			if err := func() error {
				s.Superuser.Reset()
				if err := s.Superuser.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"superuser\"")
			}
		case "userId":
			if err := func() error {
				s.UserId.Reset()
				if err := s.UserId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userId\"")
			}
		case "workspace":
			if err := func() error {
				s.Workspace.Reset()
				if err := s.Workspace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspace\"")
			}
		case "workspaceAdmin":
			if err := func() error {
				s.WorkspaceAdmin.Reset()
				if err := s.WorkspaceAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceAdmin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RescaleUser")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RescaleUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RescaleUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Status as json.
func (s Status) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Status from json.
func (s *Status) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Status to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Status(v) {
	case StatusREADY:
		*s = StatusREADY
	case StatusPENDING:
		*s = StatusPENDING
	default:
		*s = Status(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Status) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Status) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Status1 as json.
func (s Status1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Status1 from json.
func (s *Status1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Status1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Status1(v) {
	case Status1PASS:
		*s = Status1PASS
	case Status1FAIL:
		*s = Status1FAIL
	default:
		*s = Status1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Status1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Status1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StorageAccessToken) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StorageAccessToken) encodeFields(e *jx.Encoder) {
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
	{
		if s.Expiration.Set {
			e.FieldStart("expiration")
			s.Expiration.Encode(e)
		}
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
	{
		if s.ProjectSharedStoragePath.Set {
			e.FieldStart("projectSharedStoragePath")
			s.ProjectSharedStoragePath.Encode(e)
		}
	}
	{
		if s.Provider.Set {
			e.FieldStart("provider")
			s.Provider.Encode(e)
		}
	}
	{
		if s.Region.Set {
			e.FieldStart("region")
			s.Region.Encode(e)
		}
	}
	{
		if s.StorageName.Set {
			e.FieldStart("storageName")
			s.StorageName.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfStorageAccessToken = [8]string{
	0: "credentials",
	1: "expiration",
	2: "projectId",
	3: "projectSharedStoragePath",
	4: "provider",
	5: "region",
	6: "storageName",
	7: "user",
}

// Decode decodes StorageAccessToken from json.
func (s *StorageAccessToken) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageAccessToken to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		case "expiration":
			if err := func() error {
				s.Expiration.Reset()
				if err := s.Expiration.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiration\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		case "projectSharedStoragePath":
			if err := func() error {
				s.ProjectSharedStoragePath.Reset()
				if err := s.ProjectSharedStoragePath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectSharedStoragePath\"")
			}
		case "provider":
			if err := func() error {
				s.Provider.Reset()
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "region":
			if err := func() error {
				s.Region.Reset()
				if err := s.Region.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "storageName":
			if err := func() error {
				s.StorageName.Reset()
				if err := s.StorageName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageName\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StorageAccessToken")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StorageAccessToken) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageAccessToken) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s StorageAccessTokenCredentials) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s StorageAccessTokenCredentials) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes StorageAccessTokenCredentials from json.
func (s *StorageAccessTokenCredentials) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageAccessTokenCredentials to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StorageAccessTokenCredentials")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StorageAccessTokenCredentials) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageAccessTokenCredentials) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *StorageAccessTokens) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *StorageAccessTokens) encodeFields(e *jx.Encoder) {
	{
		if s.DefaultRegion.Set {
			e.FieldStart("defaultRegion")
			s.DefaultRegion.Encode(e)
		}
	}
	{
		if s.RegionStores != nil {
			e.FieldStart("regionStores")
			e.ArrStart()
			for _, elem := range s.RegionStores {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfStorageAccessTokens = [2]string{
	0: "defaultRegion",
	1: "regionStores",
}

// Decode decodes StorageAccessTokens from json.
func (s *StorageAccessTokens) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageAccessTokens to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "defaultRegion":
			if err := func() error {
				s.DefaultRegion.Reset()
				if err := s.DefaultRegion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"defaultRegion\"")
			}
		case "regionStores":
			if err := func() error {
				s.RegionStores = make([]StorageAccessToken, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StorageAccessToken
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RegionStores = append(s.RegionStores, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regionStores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StorageAccessTokens")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *StorageAccessTokens) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageAccessTokens) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Tag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Tag) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfTag = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes Tag from json.
func (s *Tag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tag to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Tag")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Tag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TaskRetentionPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TaskRetentionPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("archiveAfter")
		e.Int32(s.ArchiveAfter)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("deleteAfter")
		e.Int32(s.DeleteAfter)
	}
	{
		if s.ProjectId.Set {
			e.FieldStart("projectId")
			s.ProjectId.Encode(e)
		}
	}
}

var jsonFieldsNameOfTaskRetentionPolicy = [4]string{
	0: "archiveAfter",
	1: "createdAt",
	2: "deleteAfter",
	3: "projectId",
}

// Decode decodes TaskRetentionPolicy from json.
func (s *TaskRetentionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TaskRetentionPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archiveAfter":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ArchiveAfter = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archiveAfter\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "deleteAfter":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DeleteAfter = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleteAfter\"")
			}
		case "projectId":
			if err := func() error {
				s.ProjectId.Reset()
				if err := s.ProjectId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TaskRetentionPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTaskRetentionPolicy) {
					name = jsonFieldsNameOfTaskRetentionPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TaskRetentionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TaskRetentionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WhoAmI) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WhoAmI) encodeFields(e *jx.Encoder) {
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.UserFeatures.Set {
			e.FieldStart("userFeatures")
			s.UserFeatures.Encode(e)
		}
	}
}

var jsonFieldsNameOfWhoAmI = [2]string{
	0: "user",
	1: "userFeatures",
}

// Decode decodes WhoAmI from json.
func (s *WhoAmI) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WhoAmI to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "userFeatures":
			if err := func() error {
				s.UserFeatures.Reset()
				if err := s.UserFeatures.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userFeatures\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WhoAmI")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WhoAmI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WhoAmI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Workspace) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Workspace) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspace = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes Workspace from json.
func (s *Workspace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Workspace to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Workspace")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Workspace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Workspace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *WorkspaceTaskRetentionPolicy) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *WorkspaceTaskRetentionPolicy) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("archiveAfter")
		e.Int32(s.ArchiveAfter)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("deleteAfter")
		e.Int32(s.DeleteAfter)
	}
	{
		if s.WorkspaceId.Set {
			e.FieldStart("workspaceId")
			s.WorkspaceId.Encode(e)
		}
	}
}

var jsonFieldsNameOfWorkspaceTaskRetentionPolicy = [4]string{
	0: "archiveAfter",
	1: "createdAt",
	2: "deleteAfter",
	3: "workspaceId",
}

// Decode decodes WorkspaceTaskRetentionPolicy from json.
func (s *WorkspaceTaskRetentionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode WorkspaceTaskRetentionPolicy to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "archiveAfter":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ArchiveAfter = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"archiveAfter\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "deleteAfter":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.DeleteAfter = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deleteAfter\"")
			}
		case "workspaceId":
			if err := func() error {
				s.WorkspaceId.Reset()
				if err := s.WorkspaceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workspaceId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode WorkspaceTaskRetentionPolicy")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfWorkspaceTaskRetentionPolicy) {
					name = jsonFieldsNameOfWorkspaceTaskRetentionPolicy[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *WorkspaceTaskRetentionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *WorkspaceTaskRetentionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
