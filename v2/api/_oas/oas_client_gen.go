// Code generated by ogen, DO NOT EDIT.

package _oas

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	AuthInvoker
	ImageInvoker
	JobInvoker
	MetricsInvoker
	ProjectInvoker
	TaskInvoker
	// AuthTokenWhoamiGet invokes GET /auth/token/whoami operation.
	//
	// This endpoint will get a JWT token payload given a bearer token.
	//
	// GET /auth/token/whoami
	AuthTokenWhoamiGet(ctx context.Context) (AuthTokenWhoamiGetRes, error)
	// HtcGcpClustersWorkspaceIdGet invokes GET /htc/gcp/clusters/{workspaceId} operation.
	//
	// This endpoint returns details about all GCP clusters that can run jobs for the specified HTC
	// workspace.
	//
	// GET /htc/gcp/clusters/{workspaceId}
	HtcGcpClustersWorkspaceIdGet(ctx context.Context, params HtcGcpClustersWorkspaceIdGetParams) (HtcGcpClustersWorkspaceIdGetRes, error)
	// HtcProjectsProjectIdDimensionsPut invokes PUT /htc/projects/{projectId}/dimensions operation.
	//
	// This endpoint allows _workspace_, _organization_, and _Rescale administrators_ to _create_,
	// _update_, or _delete_ the dimension combinations for a project. It accepts a list of dimension
	// combinations, each specifying a unique set of computing environment attributes to tailor the
	// computing environment(s) of a project to match specific job requirements.
	// For example, a projectâ€™s dimensions can be configured to require jobs to run on a particular
	// type of processor architecture, within a certain region, and with or without hyperthreading.
	// It's important to note that the dimensions set through this endpoint must align with the available
	// dimensions at the workspace level.
	// **In the event that a project's dimension requirements need to be reset to allow for a broader
	// range of job types, sending an empty list to this endpoint will remove all existing dimension
	// restrictions, returning the project to a state where it can accommodate any dimension available in
	// the workspace.**.
	//
	// PUT /htc/projects/{projectId}/dimensions
	HtcProjectsProjectIdDimensionsPut(ctx context.Context, request []HTCComputeEnvironment, params HtcProjectsProjectIdDimensionsPutParams) (HtcProjectsProjectIdDimensionsPutRes, error)
	// HtcProjectsProjectIdLimitsDelete invokes DELETE /htc/projects/{projectId}/limits operation.
	//
	// This endpoint will remove all resource limits associated with this project.
	// Any jobs `SUBMITTED_TO_RESCALE` will transition to `SUBMITTED_TO_PROVIDER` if no other limits apply.
	//
	// DELETE /htc/projects/{projectId}/limits
	HtcProjectsProjectIdLimitsDelete(ctx context.Context, params HtcProjectsProjectIdLimitsDeleteParams) (HtcProjectsProjectIdLimitsDeleteRes, error)
	// HtcProjectsProjectIdLimitsIDDelete invokes DELETE /htc/projects/{projectId}/limits/{id} operation.
	//
	// This endpoint will remove a single resource limit associated with this project if it exists.
	//
	// DELETE /htc/projects/{projectId}/limits/{id}
	HtcProjectsProjectIdLimitsIDDelete(ctx context.Context, params HtcProjectsProjectIdLimitsIDDeleteParams) (HtcProjectsProjectIdLimitsIDDeleteRes, error)
	// HtcProjectsProjectIdLimitsIDGet invokes GET /htc/projects/{projectId}/limits/{id} operation.
	//
	// This endpoint will get either the `PROJECT_ADMIN` or `WORKSPACE_ADMIN` limit for this project.
	//
	// GET /htc/projects/{projectId}/limits/{id}
	HtcProjectsProjectIdLimitsIDGet(ctx context.Context, params HtcProjectsProjectIdLimitsIDGetParams) (HtcProjectsProjectIdLimitsIDGetRes, error)
	// HtcProjectsProjectIdLimitsIDPatch invokes PATCH /htc/projects/{projectId}/limits/{id} operation.
	//
	// This endpoint will update one of the existing resource limits associated with this project.
	// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
	// permissions are required to modify the `WORKSPACE_ADMIN` limit.
	//
	// PATCH /htc/projects/{projectId}/limits/{id}
	HtcProjectsProjectIdLimitsIDPatch(ctx context.Context, request OptHTCLimitUpdate, params HtcProjectsProjectIdLimitsIDPatchParams) (HtcProjectsProjectIdLimitsIDPatchRes, error)
	// HtcProjectsProjectIdLimitsPost invokes POST /htc/projects/{projectId}/limits operation.
	//
	// This endpoint will add a new limit to this project or overwrite an existing limit if one already
	// exists with the provided `modifierRole`.
	// Jobs submitted to this project will only run when the active resource count falls below the
	// minimum of all limits associated with this project.
	// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
	// permissions are required to modify the `WORKSPACE_ADMIN` limit.
	//
	// POST /htc/projects/{projectId}/limits
	HtcProjectsProjectIdLimitsPost(ctx context.Context, request OptHTCLimitCreate, params HtcProjectsProjectIdLimitsPostParams) (HtcProjectsProjectIdLimitsPostRes, error)
	// HtcProjectsProjectIdPatch invokes PATCH /htc/projects/{projectId} operation.
	//
	// This endpoint allows for updating a project's regions.
	//
	// PATCH /htc/projects/{projectId}
	HtcProjectsProjectIdPatch(ctx context.Context, request OptHTCProjectUpdate, params HtcProjectsProjectIdPatchParams) (HtcProjectsProjectIdPatchRes, error)
	// HtcProjectsProjectIdStoragePresignedURLGet invokes GET /htc/projects/{projectId}/storage/presigned-url operation.
	//
	// This endpoint will get a presigned url for project storage.
	//
	// GET /htc/projects/{projectId}/storage/presigned-url
	HtcProjectsProjectIdStoragePresignedURLGet(ctx context.Context, params HtcProjectsProjectIdStoragePresignedURLGetParams) (HtcProjectsProjectIdStoragePresignedURLGetRes, error)
	// HtcProjectsProjectIdStorageTokenGet invokes GET /htc/projects/{projectId}/storage/token operation.
	//
	// This endpoint will get temporary access information for a project storage.
	//
	// GET /htc/projects/{projectId}/storage/token
	HtcProjectsProjectIdStorageTokenGet(ctx context.Context, params HtcProjectsProjectIdStorageTokenGetParams) (HtcProjectsProjectIdStorageTokenGetRes, error)
	// HtcProjectsProjectIdStorageTokenRegionGet invokes GET /htc/projects/{projectId}/storage/token/{region} operation.
	//
	// This endpoint will get temporary access information for a project storage given a region.
	//
	// GET /htc/projects/{projectId}/storage/token/{region}
	HtcProjectsProjectIdStorageTokenRegionGet(ctx context.Context, params HtcProjectsProjectIdStorageTokenRegionGetParams) (HtcProjectsProjectIdStorageTokenRegionGetRes, error)
	// HtcProjectsProjectIdStorageTokensGet invokes GET /htc/projects/{projectId}/storage/tokens operation.
	//
	// This endpoint will get temporary access information for all project storages.
	//
	// GET /htc/projects/{projectId}/storage/tokens
	HtcProjectsProjectIdStorageTokensGet(ctx context.Context, params HtcProjectsProjectIdStorageTokensGetParams) (HtcProjectsProjectIdStorageTokensGetRes, error)
	// HtcProjectsProjectIdTaskRetentionPolicyDelete invokes DELETE /htc/projects/{projectId}/task-retention-policy operation.
	//
	// This endpoint allows users to delete the task retention policy for the specified project. When a
	// project-level policy is deleted, the auto-archival and auto-deletion behavior for tasks within the
	// project will fall back to the workspace-level policy (if any). If no workspace-level policy is set,
	//  tasks within the project will not be subject to any auto-archival or auto-deletion.
	//
	// DELETE /htc/projects/{projectId}/task-retention-policy
	HtcProjectsProjectIdTaskRetentionPolicyDelete(ctx context.Context, params HtcProjectsProjectIdTaskRetentionPolicyDeleteParams) (HtcProjectsProjectIdTaskRetentionPolicyDeleteRes, error)
	// HtcProjectsProjectIdTaskRetentionPolicyGet invokes GET /htc/projects/{projectId}/task-retention-policy operation.
	//
	// This endpoint is used to retrieve the current task retention policy of a specific project. The
	// task retention policy is necessary in managing the lifecycle of tasks within a project. The task
	// retention policy includes two key aspects:
	// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
	// which an archived task is automatically deleted. Archived tasks can be unarchived during this
	// period, protecting users from prematurely deleting task resources.
	// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
	// of inactivity after which an active task is automatically archived. This feature helps in keeping
	// the project organized by archiving active tasks, ensuring that storage resources are freed
	// optimistically.
	// Setting either value to `0` will result in disabling of that feature. For example, a project's
	// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
	// auto-deleting.
	// If no policy is set at the project level (i.e., the response is a 404), the policy at the
	// workspace level will apply. If the policy has archiveAfter or deleteAfter set to 0, it means that
	// auto-archival or auto-deletion is disabled at the project level and any workspace level policy is
	// ignored.
	//
	// GET /htc/projects/{projectId}/task-retention-policy
	HtcProjectsProjectIdTaskRetentionPolicyGet(ctx context.Context, params HtcProjectsProjectIdTaskRetentionPolicyGetParams) (HtcProjectsProjectIdTaskRetentionPolicyGetRes, error)
	// HtcProjectsProjectIdTaskRetentionPolicyPut invokes PUT /htc/projects/{projectId}/task-retention-policy operation.
	//
	// This endpoint enables project administrators to define or update the task retention policy for a
	// specific project. The task retention policy includes two key aspects:
	// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
	// hours) after which an archived task is automatically deleted. This control allows for flexibility
	// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
	// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
	// from prematurely deleting task resources
	// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
	// duration (in hours) of inactivity after which an active task is automatically archived. This
	// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
	// resources are freed optimistically.
	// Setting either value to `0` will result in disabling of that feature. For example, a project's
	// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
	// auto-deleting.If no policy is set at the project level, the workspace-level policy (if any) will
	// be applied to the project.
	//
	// PUT /htc/projects/{projectId}/task-retention-policy
	HtcProjectsProjectIdTaskRetentionPolicyPut(ctx context.Context, request OptTaskRetentionPolicy, params HtcProjectsProjectIdTaskRetentionPolicyPutParams) (HtcProjectsProjectIdTaskRetentionPolicyPutRes, error)
	// HtcProjectsProjectIdTasksTaskIdDelete invokes DELETE /htc/projects/{projectId}/tasks/{taskId} operation.
	//
	// This endpoint will delete a task by ID.
	//
	// DELETE /htc/projects/{projectId}/tasks/{taskId}
	HtcProjectsProjectIdTasksTaskIdDelete(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdDeleteParams) (HtcProjectsProjectIdTasksTaskIdDeleteRes, error)
	// HtcProjectsProjectIdTasksTaskIdGet invokes GET /htc/projects/{projectId}/tasks/{taskId} operation.
	//
	// This endpoint will get a task by ID.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}
	HtcProjectsProjectIdTasksTaskIdGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGetParams) (HtcProjectsProjectIdTasksTaskIdGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics operation.
	//
	// This endpoint will get job status summary statistics for each group in a task.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics
	HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams) (HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdGroupsGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/groups operation.
	//
	// This endpoint will get task groups.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/groups
	HtcProjectsProjectIdTasksTaskIdGroupsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGroupsGetParams) (HtcProjectsProjectIdTasksTaskIdGroupsGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/events operation.
	//
	// This endpoint will get events for a job.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/events
	HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetParams) (HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdPatch invokes PATCH /htc/projects/{projectId}/tasks/{taskId} operation.
	//
	// This endpoint allows for managing the lifecycle of tasks. Users may set the `LifecycleStatus` of
	// an HTCTask in accordance with their data retention requirements.
	// Archiving a Task: To archive an active task, submit a PATCH request with "lifecycleStatus":
	// "ARCHIVED". This action is permissible only if the task is currently active and has no running
	// jobs. Once archived, the task enters a state where it is no longer operational, but its data is
	// retained. An archived task will be automatically scheduled for deletion after a period defined in
	// the project's task retention policy.
	// Unarchiving a Task: If a task is in an archived state and you wish to defer its automatic deletion,
	//  you can restore it to an active state. To unarchive a task, PATCH it with "lifecycleStatus":
	// "ACTIVE". This action reactivates the task, making it modifiable and operational again. Note that
	// this action is only applicable to tasks in the ARCHIVED state.
	// Restrictions: Tasks in a DELETED state are immutable and cannot be transitioned to any other state
	// using this endpoint. Similarly, tasks can only be archived if they are in an ACTIVE state and do
	// not have any running jobs.
	//
	// PATCH /htc/projects/{projectId}/tasks/{taskId}
	HtcProjectsProjectIdTasksTaskIdPatch(ctx context.Context, request OptHTCTaskUpdate, params HtcProjectsProjectIdTasksTaskIdPatchParams) (HtcProjectsProjectIdTasksTaskIdPatchRes, error)
	// HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url operation.
	//
	// This endpoint will get a presigned url for task storage.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url
	HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams) (HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage operation.
	//
	// This endpoint will get temporary access information for all task storages.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage
	HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams) (HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdStorageTokenGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/token operation.
	//
	// This endpoint will get temporary access information for a task storage.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token
	HtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokenGetParams) (HtcProjectsProjectIdTasksTaskIdStorageTokenGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region} operation.
	//
	// This endpoint will get temporary access information for a task storage given a region.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region}
	HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams) (HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRes, error)
	// HtcProjectsProjectIdTasksTaskIdStorageTokensGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens operation.
	//
	// This endpoint will get temporary access information for all task storages.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens
	HtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokensGetParams) (HtcProjectsProjectIdTasksTaskIdStorageTokensGetRes, error)
	// HtcRegionsGet invokes GET /htc/regions operation.
	//
	// This endpoint will get HTC region settings for all regions.
	//
	// GET /htc/regions
	HtcRegionsGet(ctx context.Context, params HtcRegionsGetParams) (HtcRegionsGetRes, error)
	// HtcRegionsRegionGet invokes GET /htc/regions/{region} operation.
	//
	// This endpoint will get HTC region settings for a specific region.
	//
	// GET /htc/regions/{region}
	HtcRegionsRegionGet(ctx context.Context, params HtcRegionsRegionGetParams) (HtcRegionsRegionGetRes, error)
	// HtcStorageGet invokes GET /htc/storage operation.
	//
	// This endpoint will get storages in all enabled regions.
	//
	// GET /htc/storage
	HtcStorageGet(ctx context.Context) (HtcStorageGetRes, error)
	// HtcStorageRegionRegionGet invokes GET /htc/storage/region/{region} operation.
	//
	// This endpoint will get a storage for a region.
	//
	// GET /htc/storage/region/{region}
	HtcStorageRegionRegionGet(ctx context.Context, params HtcStorageRegionRegionGetParams) (HtcStorageRegionRegionGetRes, error)
	// HtcWorkspacesWorkspaceIdDimensionsGet invokes GET /htc/workspaces/{workspaceId}/dimensions operation.
	//
	// This endpoint provides a comprehensive view of the various hardware configurations and
	// environments available within a specific workspace. This read-only API is primarily designed for
	// users who need to understand the different "dimensions" or attributes that describe the hardware
	// and other aspects of job runs within their workspace. By offering insights into available
	// environments, it aids users in selecting the most suitable configuration for their jobs,
	// especially when performance testing across different hardware setups.
	// Normal users can access this endpoint for the workspace they belong to
	// Rescale personnel are required in order to modify any of these dimensions.
	//
	// GET /htc/workspaces/{workspaceId}/dimensions
	HtcWorkspacesWorkspaceIdDimensionsGet(ctx context.Context, params HtcWorkspacesWorkspaceIdDimensionsGetParams) (HtcWorkspacesWorkspaceIdDimensionsGetRes, error)
	// HtcWorkspacesWorkspaceIdLimitsGet invokes GET /htc/workspaces/{workspaceId}/limits operation.
	//
	// This endpoint will get the resource limit applied to this workspace.
	//
	// GET /htc/workspaces/{workspaceId}/limits
	HtcWorkspacesWorkspaceIdLimitsGet(ctx context.Context, params HtcWorkspacesWorkspaceIdLimitsGetParams) (HtcWorkspacesWorkspaceIdLimitsGetRes, error)
	// HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet invokes GET /htc/workspaces/{workspaceId}/task-retention-policy operation.
	//
	// This endpoint is used to retrieve the current task retention policy of a specific Workspace. The
	// task retention policy is necessary in managing the lifecycle of tasks within a Workspace. The task
	// retention policy includes two key aspects:
	// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
	// which an archived task is automatically deleted. Archived tasks can be unarchived during this
	// period, protecting users from prematurely deleting task resources.
	// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
	// of inactivity after which an active task is automatically archived. This feature helps in keeping
	// the project organized by archiving active tasks, ensuring that storage resources are freed
	// optimistically.
	// Setting either value to `0` will result in disabling of that feature. For example, a project's
	// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
	// auto-deleting.
	//
	// GET /htc/workspaces/{workspaceId}/task-retention-policy
	HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet(ctx context.Context, params HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetParams) (HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetRes, error)
	// HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut invokes PUT /htc/workspaces/{workspaceId}/task-retention-policy operation.
	//
	// This endpoint enables Workspace administrators to define or update the task retention policy for a
	// specific workspace. The task retention policy includes two key aspects:
	// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
	// hours) after which an archived task is automatically deleted. This control allows for flexibility
	// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
	// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
	// from prematurely deleting task resources
	// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
	// duration (in hours) of inactivity after which an active task is automatically archived. This
	// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
	// resources are freed optimistically.
	// Setting either value to `0` will result in disabling of that feature. For example, a workspace's
	// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
	// auto-deleting. The policy applies to all projects within the workspace that do not have their own
	// project-level policy defined. If a project within the workspace has its own retention policy
	// defined, the project-level policy takes precedence over the workspace-level policy.
	//
	// PUT /htc/workspaces/{workspaceId}/task-retention-policy
	HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut(ctx context.Context, request OptWorkspaceTaskRetentionPolicy, params HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutParams) (HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRes, error)
	// OAuth2TokenPost invokes POST /oauth2/token operation.
	//
	// This endpoint will get an OAuth access token.
	//
	// POST /oauth2/token
	OAuth2TokenPost(ctx context.Context) (OAuth2TokenPostRes, error)
	// WellKnownJwksJSONGet invokes GET /.well-known/jwks.json operation.
	//
	// This endpoint will get the public keys used to verify JWT.
	//
	// GET /.well-known/jwks.json
	WellKnownJwksJSONGet(ctx context.Context) (WellKnownJwksJSONGetRes, error)
}

// AuthInvoker invokes operations described by OpenAPI v3 specification.
//
// x-gen-operation-group: Auth
type AuthInvoker interface {
	// GetToken invokes getToken operation.
	//
	// This endpoint will get a JWT token given an API key.
	//
	// GET /auth/token
	GetToken(ctx context.Context) (GetTokenRes, error)
	// WhoAmI invokes whoAmI operation.
	//
	// This endpoint will get Rescale user information given a Rescale API key.
	//
	// GET /auth/whoami
	WhoAmI(ctx context.Context) (WhoAmIRes, error)
}

// ImageInvoker invokes operations described by OpenAPI v3 specification.
//
// x-gen-operation-group: Image
type ImageInvoker interface {
	// CreateRepo invokes createRepo operation.
	//
	// This endpoint will create a private container repository belonging to this project
	// Private container registries are collections of repositories, and private repositories are
	// collections of container images. These images are referenced when running jobs within this project.
	//  In order to upload an image to a repository, you will need the `registryURI`, the
	// `repositoryName`, and the token (see `/htc/projects/:projectId/container-registry/token`).
	//
	// POST /htc/projects/{projectId}/container-registry/repo/{repoName}
	CreateRepo(ctx context.Context, params CreateRepoParams) (CreateRepoRes, error)
	// GetImage invokes getImage operation.
	//
	// Retrieves the current status of an image across cloud providers. The status indicates whether the
	// image is ready for use or still being processed. Returns READY when the image is available in all
	// cloud providers, PENDING while the image is being replicated, and a 404 if the image does not
	// exist.
	//
	// GET /htc/projects/{projectId}/container-registry/images/{imageName}
	GetImage(ctx context.Context, params GetImageParams) (GetImageRes, error)
	// GetImages invokes getImages operation.
	//
	// This endpoint will list all images for a project.
	//
	// GET /htc/projects/{projectId}/container-registry/images
	GetImages(ctx context.Context, params GetImagesParams) (GetImagesRes, error)
	// GetRegistryToken invokes getRegistryToken operation.
	//
	// This endpoint will get a container registry authorization token.
	// To use this token run `docker login --username AWS --password {TOKEN} {CONTAINER_REGISTRY_DOMAIN}`.
	// e.g. `docker login --username AWS --password "eyJwYXlsb2FkIjoiZHhtSzJuQ0x..." 183929446192.dkr.ecr.
	// us-west-2.amazonaws.com`.
	//
	// GET /htc/projects/{projectId}/container-registry/token
	GetRegistryToken(ctx context.Context, params GetRegistryTokenParams) (GetRegistryTokenRes, error)
}

// JobInvoker invokes operations described by OpenAPI v3 specification.
//
// x-gen-operation-group: Job
type JobInvoker interface {
	// CancelJobs invokes cancelJobs operation.
	//
	// This endpoint will attempt to cancel submitted jobs.
	// Note a 200 response status code does not mean all jobs were cancelled.
	//
	// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/cancel
	CancelJobs(ctx context.Context, params CancelJobsParams) (CancelJobsRes, error)
	// GetJob invokes getJob operation.
	//
	// This endpoint will get a job by id.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}
	GetJob(ctx context.Context, params GetJobParams) (GetJobRes, error)
	// GetJobs invokes getJobs operation.
	//
	// This endpoint will get all jobs for a task.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/jobs
	GetJobs(ctx context.Context, params GetJobsParams) (GetJobsRes, error)
	// GetLogs invokes getLogs operation.
	//
	// This endpoint will get job logs.
	//
	// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/logs
	GetLogs(ctx context.Context, params GetLogsParams) (GetLogsRes, error)
	// SubmitJobs invokes submitJobs operation.
	//
	// This endpoint will submit a batch of jobs for a task.
	//
	// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/batch
	SubmitJobs(ctx context.Context, request []HTCJobSubmitRequest, params SubmitJobsParams) (SubmitJobsRes, error)
}

// MetricsInvoker invokes operations described by OpenAPI v3 specification.
//
// x-gen-operation-group: Metrics
type MetricsInvoker interface {
	// GetMetrics invokes getMetrics operation.
	//
	// Get all HTC Metrics for a workspace.
	//
	// GET /htc/metrics
	GetMetrics(ctx context.Context, params GetMetricsParams) (GetMetricsRes, error)
}

// ProjectInvoker invokes operations described by OpenAPI v3 specification.
//
// x-gen-operation-group: Project
type ProjectInvoker interface {
	// CreateProject invokes createProject operation.
	//
	// This endpoint will create a project. A project is a collection of tasks and container images used
	// to run jobs. Several projects can belong to a single workspace.
	//
	// POST /htc/projects
	CreateProject(ctx context.Context, request OptHTCProject) (CreateProjectRes, error)
	// GetDimensions invokes getDimensions operation.
	//
	// This endpoint is designed to retrieve the current set of dimension combinations configured for a
	// specific project so that users can understand the existing computing environment constraints of a
	// project. It returns a list of dimension combinations such as pricing priority, geographical region,
	//  compute scaling policy, and hyperthreading options.
	// Any user who _belongs to the workspace this project belongs to_ can use this endpoint to verify or
	// audit the current configuration of a project. This can be helpful in ensuring that the project's
	// settings align with expectations.
	// The payload also includes a read-only set of `derived` dimensions which help describe the
	// currently configured `machineType`.
	//
	// GET /htc/projects/{projectId}/dimensions
	GetDimensions(ctx context.Context, params GetDimensionsParams) (GetDimensionsRes, error)
	// GetLimits invokes getLimits operation.
	//
	// This endpoint will list all resource limitations associated with this project.
	// A job running in this project will be subject to all resulting limits as well as any associated
	// with the workspace (see `/htc/workspaces/{workspaceId}/limits`).
	//
	// GET /htc/projects/{projectId}/limits
	GetLimits(ctx context.Context, params GetLimitsParams) (GetLimitsRes, error)
	// GetProject invokes getProject operation.
	//
	// This endpoint will get a project by id.
	//
	// GET /htc/projects/{projectId}
	GetProject(ctx context.Context, params GetProjectParams) (GetProjectRes, error)
	// GetProjects invokes getProjects operation.
	//
	// This endpoint will get all projects.
	//
	// GET /htc/projects
	GetProjects(ctx context.Context, params GetProjectsParams) (GetProjectsRes, error)
}

// TaskInvoker invokes operations described by OpenAPI v3 specification.
//
// x-gen-operation-group: Task
type TaskInvoker interface {
	// CreateTask invokes createTask operation.
	//
	// This endpoint will create a task for a project.
	//
	// POST /htc/projects/{projectId}/tasks
	CreateTask(ctx context.Context, request OptHTCTask, params CreateTaskParams) (CreateTaskRes, error)
	// GetTasks invokes getTasks operation.
	//
	// This endpoint will get all tasks in a project.
	//
	// GET /htc/projects/{projectId}/tasks
	GetTasks(ctx context.Context, params GetTasksParams) (GetTasksRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

var _ Handler = struct {
	*Client
}{}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AuthTokenWhoamiGet invokes GET /auth/token/whoami operation.
//
// This endpoint will get a JWT token payload given a bearer token.
//
// GET /auth/token/whoami
func (c *Client) AuthTokenWhoamiGet(ctx context.Context) (AuthTokenWhoamiGetRes, error) {
	res, err := c.sendAuthTokenWhoamiGet(ctx)
	return res, err
}

func (c *Client) sendAuthTokenWhoamiGet(ctx context.Context) (res AuthTokenWhoamiGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/token/whoami"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "AuthTokenWhoamiGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAuthTokenWhoamiGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CancelJobs invokes cancelJobs operation.
//
// This endpoint will attempt to cancel submitted jobs.
// Note a 200 response status code does not mean all jobs were cancelled.
//
// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/cancel
func (c *Client) CancelJobs(ctx context.Context, params CancelJobsParams) (CancelJobsRes, error) {
	res, err := c.sendCancelJobs(ctx, params)
	return res, err
}

func (c *Client) sendCancelJobs(ctx context.Context, params CancelJobsParams) (res CancelJobsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/jobs/cancel"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "group" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Group.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "CancelJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCancelJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateProject invokes createProject operation.
//
// This endpoint will create a project. A project is a collection of tasks and container images used
// to run jobs. Several projects can belong to a single workspace.
//
// POST /htc/projects
func (c *Client) CreateProject(ctx context.Context, request OptHTCProject) (CreateProjectRes, error) {
	res, err := c.sendCreateProject(ctx, request)
	return res, err
}

func (c *Client) sendCreateProject(ctx context.Context, request OptHTCProject) (res CreateProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/htc/projects"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "CreateProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateRepo invokes createRepo operation.
//
// This endpoint will create a private container repository belonging to this project
// Private container registries are collections of repositories, and private repositories are
// collections of container images. These images are referenced when running jobs within this project.
//
//	In order to upload an image to a repository, you will need the `registryURI`, the
//
// `repositoryName`, and the token (see `/htc/projects/:projectId/container-registry/token`).
//
// POST /htc/projects/{projectId}/container-registry/repo/{repoName}
func (c *Client) CreateRepo(ctx context.Context, params CreateRepoParams) (CreateRepoRes, error) {
	res, err := c.sendCreateRepo(ctx, params)
	return res, err
}

func (c *Client) sendCreateRepo(ctx context.Context, params CreateRepoParams) (res CreateRepoRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/container-registry/repo/"
	{
		// Encode "repoName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "repoName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.RepoName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "CreateRepo", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateRepoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateTask invokes createTask operation.
//
// This endpoint will create a task for a project.
//
// POST /htc/projects/{projectId}/tasks
func (c *Client) CreateTask(ctx context.Context, request OptHTCTask, params CreateTaskParams) (CreateTaskRes, error) {
	res, err := c.sendCreateTask(ctx, request, params)
	return res, err
}

func (c *Client) sendCreateTask(ctx context.Context, request OptHTCTask, params CreateTaskParams) (res CreateTaskRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateTaskRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "CreateTask", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateTaskResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDimensions invokes getDimensions operation.
//
// This endpoint is designed to retrieve the current set of dimension combinations configured for a
// specific project so that users can understand the existing computing environment constraints of a
// project. It returns a list of dimension combinations such as pricing priority, geographical region,
//
//	compute scaling policy, and hyperthreading options.
//
// Any user who _belongs to the workspace this project belongs to_ can use this endpoint to verify or
// audit the current configuration of a project. This can be helpful in ensuring that the project's
// settings align with expectations.
// The payload also includes a read-only set of `derived` dimensions which help describe the
// currently configured `machineType`.
//
// GET /htc/projects/{projectId}/dimensions
func (c *Client) GetDimensions(ctx context.Context, params GetDimensionsParams) (GetDimensionsRes, error) {
	res, err := c.sendGetDimensions(ctx, params)
	return res, err
}

func (c *Client) sendGetDimensions(ctx context.Context, params GetDimensionsParams) (res GetDimensionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dimensions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetDimensions", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDimensionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetImage invokes getImage operation.
//
// Retrieves the current status of an image across cloud providers. The status indicates whether the
// image is ready for use or still being processed. Returns READY when the image is available in all
// cloud providers, PENDING while the image is being replicated, and a 404 if the image does not
// exist.
//
// GET /htc/projects/{projectId}/container-registry/images/{imageName}
func (c *Client) GetImage(ctx context.Context, params GetImageParams) (GetImageRes, error) {
	res, err := c.sendGetImage(ctx, params)
	return res, err
}

func (c *Client) sendGetImage(ctx context.Context, params GetImageParams) (res GetImageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/container-registry/images/"
	{
		// Encode "imageName" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "imageName",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ImageName))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetImage", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetImages invokes getImages operation.
//
// This endpoint will list all images for a project.
//
// GET /htc/projects/{projectId}/container-registry/images
func (c *Client) GetImages(ctx context.Context, params GetImagesParams) (GetImagesRes, error) {
	res, err := c.sendGetImages(ctx, params)
	return res, err
}

func (c *Client) sendGetImages(ctx context.Context, params GetImagesParams) (res GetImagesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/container-registry/images"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetImages", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetImagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetJob invokes getJob operation.
//
// This endpoint will get a job by id.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}
func (c *Client) GetJob(ctx context.Context, params GetJobParams) (GetJobRes, error) {
	res, err := c.sendGetJob(ctx, params)
	return res, err
}

func (c *Client) sendGetJob(ctx context.Context, params GetJobParams) (res GetJobRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/jobs/"
	{
		// Encode "jobId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "jobId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.JobId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetJob", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetJobResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetJobs invokes getJobs operation.
//
// This endpoint will get all jobs for a task.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs
func (c *Client) GetJobs(ctx context.Context, params GetJobsParams) (GetJobsRes, error) {
	res, err := c.sendGetJobs(ctx, params)
	return res, err
}

func (c *Client) sendGetJobs(ctx context.Context, params GetJobsParams) (res GetJobsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/jobs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "group" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Group.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "jobId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "jobId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.JobId != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.JobId {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "status" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Status.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "viewType" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "viewType",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ViewType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLimits invokes getLimits operation.
//
// This endpoint will list all resource limitations associated with this project.
// A job running in this project will be subject to all resulting limits as well as any associated
// with the workspace (see `/htc/workspaces/{workspaceId}/limits`).
//
// GET /htc/projects/{projectId}/limits
func (c *Client) GetLimits(ctx context.Context, params GetLimitsParams) (GetLimitsRes, error) {
	res, err := c.sendGetLimits(ctx, params)
	return res, err
}

func (c *Client) sendGetLimits(ctx context.Context, params GetLimitsParams) (res GetLimitsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetLimits", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLimitsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLogs invokes getLogs operation.
//
// This endpoint will get job logs.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/logs
func (c *Client) GetLogs(ctx context.Context, params GetLogsParams) (GetLogsRes, error) {
	res, err := c.sendGetLogs(ctx, params)
	return res, err
}

func (c *Client) sendGetLogs(ctx context.Context, params GetLogsParams) (res GetLogsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/jobs/"
	{
		// Encode "jobId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "jobId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.JobId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetLogs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMetrics invokes getMetrics operation.
//
// Get all HTC Metrics for a workspace.
//
// GET /htc/metrics
func (c *Client) GetMetrics(ctx context.Context, params GetMetricsParams) (GetMetricsRes, error) {
	res, err := c.sendGetMetrics(ctx, params)
	return res, err
}

func (c *Client) sendGetMetrics(ctx context.Context, params GetMetricsParams) (res GetMetricsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/htc/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "Accept-Encoding",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.AcceptEncoding != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.AcceptEncoding {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetMetrics", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProject invokes getProject operation.
//
// This endpoint will get a project by id.
//
// GET /htc/projects/{projectId}
func (c *Client) GetProject(ctx context.Context, params GetProjectParams) (GetProjectRes, error) {
	res, err := c.sendGetProject(ctx, params)
	return res, err
}

func (c *Client) sendGetProject(ctx context.Context, params GetProjectParams) (res GetProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetProject", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjects invokes getProjects operation.
//
// This endpoint will get all projects.
//
// GET /htc/projects
func (c *Client) GetProjects(ctx context.Context, params GetProjectsParams) (GetProjectsRes, error) {
	res, err := c.sendGetProjects(ctx, params)
	return res, err
}

func (c *Client) sendGetProjects(ctx context.Context, params GetProjectsParams) (res GetProjectsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/htc/projects"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "onlyMyProjects" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "onlyMyProjects",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OnlyMyProjects.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetProjects", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRegistryToken invokes getRegistryToken operation.
//
// This endpoint will get a container registry authorization token.
// To use this token run `docker login --username AWS --password {TOKEN} {CONTAINER_REGISTRY_DOMAIN}`.
// e.g. `docker login --username AWS --password "eyJwYXlsb2FkIjoiZHhtSzJuQ0x..." 183929446192.dkr.ecr.
// us-west-2.amazonaws.com`.
//
// GET /htc/projects/{projectId}/container-registry/token
func (c *Client) GetRegistryToken(ctx context.Context, params GetRegistryTokenParams) (GetRegistryTokenRes, error) {
	res, err := c.sendGetRegistryToken(ctx, params)
	return res, err
}

func (c *Client) sendGetRegistryToken(ctx context.Context, params GetRegistryTokenParams) (res GetRegistryTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/container-registry/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetRegistryToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRegistryTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTasks invokes getTasks operation.
//
// This endpoint will get all tasks in a project.
//
// GET /htc/projects/{projectId}/tasks
func (c *Client) GetTasks(ctx context.Context, params GetTasksParams) (GetTasksRes, error) {
	res, err := c.sendGetTasks(ctx, params)
	return res, err
}

func (c *Client) sendGetTasks(ctx context.Context, params GetTasksParams) (res GetTasksRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetTasks", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTasksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetToken invokes getToken operation.
//
// This endpoint will get a JWT token given an API key.
//
// GET /auth/token
func (c *Client) GetToken(ctx context.Context) (GetTokenRes, error) {
	res, err := c.sendGetToken(ctx)
	return res, err
}

func (c *Client) sendGetToken(ctx context.Context) (res GetTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "GetToken", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcGcpClustersWorkspaceIdGet invokes GET /htc/gcp/clusters/{workspaceId} operation.
//
// This endpoint returns details about all GCP clusters that can run jobs for the specified HTC
// workspace.
//
// GET /htc/gcp/clusters/{workspaceId}
func (c *Client) HtcGcpClustersWorkspaceIdGet(ctx context.Context, params HtcGcpClustersWorkspaceIdGetParams) (HtcGcpClustersWorkspaceIdGetRes, error) {
	res, err := c.sendHtcGcpClustersWorkspaceIdGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcGcpClustersWorkspaceIdGet(ctx context.Context, params HtcGcpClustersWorkspaceIdGetParams) (res HtcGcpClustersWorkspaceIdGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/htc/gcp/clusters/"
	{
		// Encode "workspaceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workspaceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkspaceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcGcpClustersWorkspaceIdGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcGcpClustersWorkspaceIdGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdDimensionsPut invokes PUT /htc/projects/{projectId}/dimensions operation.
//
// This endpoint allows _workspace_, _organization_, and _Rescale administrators_ to _create_,
// _update_, or _delete_ the dimension combinations for a project. It accepts a list of dimension
// combinations, each specifying a unique set of computing environment attributes to tailor the
// computing environment(s) of a project to match specific job requirements.
// For example, a projectâ€™s dimensions can be configured to require jobs to run on a particular
// type of processor architecture, within a certain region, and with or without hyperthreading.
// It's important to note that the dimensions set through this endpoint must align with the available
// dimensions at the workspace level.
// **In the event that a project's dimension requirements need to be reset to allow for a broader
// range of job types, sending an empty list to this endpoint will remove all existing dimension
// restrictions, returning the project to a state where it can accommodate any dimension available in
// the workspace.**.
//
// PUT /htc/projects/{projectId}/dimensions
func (c *Client) HtcProjectsProjectIdDimensionsPut(ctx context.Context, request []HTCComputeEnvironment, params HtcProjectsProjectIdDimensionsPutParams) (HtcProjectsProjectIdDimensionsPutRes, error) {
	res, err := c.sendHtcProjectsProjectIdDimensionsPut(ctx, request, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdDimensionsPut(ctx context.Context, request []HTCComputeEnvironment, params HtcProjectsProjectIdDimensionsPutParams) (res HtcProjectsProjectIdDimensionsPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dimensions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHtcProjectsProjectIdDimensionsPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdDimensionsPut", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdDimensionsPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdLimitsDelete invokes DELETE /htc/projects/{projectId}/limits operation.
//
// This endpoint will remove all resource limits associated with this project.
// Any jobs `SUBMITTED_TO_RESCALE` will transition to `SUBMITTED_TO_PROVIDER` if no other limits apply.
//
// DELETE /htc/projects/{projectId}/limits
func (c *Client) HtcProjectsProjectIdLimitsDelete(ctx context.Context, params HtcProjectsProjectIdLimitsDeleteParams) (HtcProjectsProjectIdLimitsDeleteRes, error) {
	res, err := c.sendHtcProjectsProjectIdLimitsDelete(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdLimitsDelete(ctx context.Context, params HtcProjectsProjectIdLimitsDeleteParams) (res HtcProjectsProjectIdLimitsDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdLimitsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdLimitsIDDelete invokes DELETE /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will remove a single resource limit associated with this project if it exists.
//
// DELETE /htc/projects/{projectId}/limits/{id}
func (c *Client) HtcProjectsProjectIdLimitsIDDelete(ctx context.Context, params HtcProjectsProjectIdLimitsIDDeleteParams) (HtcProjectsProjectIdLimitsIDDeleteRes, error) {
	res, err := c.sendHtcProjectsProjectIdLimitsIDDelete(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdLimitsIDDelete(ctx context.Context, params HtcProjectsProjectIdLimitsIDDeleteParams) (res HtcProjectsProjectIdLimitsIDDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/limits/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdLimitsIDDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdLimitsIDGet invokes GET /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will get either the `PROJECT_ADMIN` or `WORKSPACE_ADMIN` limit for this project.
//
// GET /htc/projects/{projectId}/limits/{id}
func (c *Client) HtcProjectsProjectIdLimitsIDGet(ctx context.Context, params HtcProjectsProjectIdLimitsIDGetParams) (HtcProjectsProjectIdLimitsIDGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdLimitsIDGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdLimitsIDGet(ctx context.Context, params HtcProjectsProjectIdLimitsIDGetParams) (res HtcProjectsProjectIdLimitsIDGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/limits/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdLimitsIDGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdLimitsIDPatch invokes PATCH /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will update one of the existing resource limits associated with this project.
// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
// permissions are required to modify the `WORKSPACE_ADMIN` limit.
//
// PATCH /htc/projects/{projectId}/limits/{id}
func (c *Client) HtcProjectsProjectIdLimitsIDPatch(ctx context.Context, request OptHTCLimitUpdate, params HtcProjectsProjectIdLimitsIDPatchParams) (HtcProjectsProjectIdLimitsIDPatchRes, error) {
	res, err := c.sendHtcProjectsProjectIdLimitsIDPatch(ctx, request, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdLimitsIDPatch(ctx context.Context, request OptHTCLimitUpdate, params HtcProjectsProjectIdLimitsIDPatchParams) (res HtcProjectsProjectIdLimitsIDPatchRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/limits/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHtcProjectsProjectIdLimitsIDPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDPatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdLimitsIDPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdLimitsPost invokes POST /htc/projects/{projectId}/limits operation.
//
// This endpoint will add a new limit to this project or overwrite an existing limit if one already
// exists with the provided `modifierRole`.
// Jobs submitted to this project will only run when the active resource count falls below the
// minimum of all limits associated with this project.
// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
// permissions are required to modify the `WORKSPACE_ADMIN` limit.
//
// POST /htc/projects/{projectId}/limits
func (c *Client) HtcProjectsProjectIdLimitsPost(ctx context.Context, request OptHTCLimitCreate, params HtcProjectsProjectIdLimitsPostParams) (HtcProjectsProjectIdLimitsPostRes, error) {
	res, err := c.sendHtcProjectsProjectIdLimitsPost(ctx, request, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdLimitsPost(ctx context.Context, request OptHTCLimitCreate, params HtcProjectsProjectIdLimitsPostParams) (res HtcProjectsProjectIdLimitsPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHtcProjectsProjectIdLimitsPostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsPost", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdLimitsPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdPatch invokes PATCH /htc/projects/{projectId} operation.
//
// This endpoint allows for updating a project's regions.
//
// PATCH /htc/projects/{projectId}
func (c *Client) HtcProjectsProjectIdPatch(ctx context.Context, request OptHTCProjectUpdate, params HtcProjectsProjectIdPatchParams) (HtcProjectsProjectIdPatchRes, error) {
	res, err := c.sendHtcProjectsProjectIdPatch(ctx, request, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdPatch(ctx context.Context, request OptHTCProjectUpdate, params HtcProjectsProjectIdPatchParams) (res HtcProjectsProjectIdPatchRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHtcProjectsProjectIdPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdPatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdStoragePresignedURLGet invokes GET /htc/projects/{projectId}/storage/presigned-url operation.
//
// This endpoint will get a presigned url for project storage.
//
// GET /htc/projects/{projectId}/storage/presigned-url
func (c *Client) HtcProjectsProjectIdStoragePresignedURLGet(ctx context.Context, params HtcProjectsProjectIdStoragePresignedURLGetParams) (HtcProjectsProjectIdStoragePresignedURLGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdStoragePresignedURLGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdStoragePresignedURLGet(ctx context.Context, params HtcProjectsProjectIdStoragePresignedURLGetParams) (res HtcProjectsProjectIdStoragePresignedURLGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage/presigned-url"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filePath" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filePath",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilePath))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdStoragePresignedURLGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdStoragePresignedURLGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdStorageTokenGet invokes GET /htc/projects/{projectId}/storage/token operation.
//
// This endpoint will get temporary access information for a project storage.
//
// GET /htc/projects/{projectId}/storage/token
func (c *Client) HtcProjectsProjectIdStorageTokenGet(ctx context.Context, params HtcProjectsProjectIdStorageTokenGetParams) (HtcProjectsProjectIdStorageTokenGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdStorageTokenGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdStorageTokenGet(ctx context.Context, params HtcProjectsProjectIdStorageTokenGetParams) (res HtcProjectsProjectIdStorageTokenGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokenGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdStorageTokenGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdStorageTokenRegionGet invokes GET /htc/projects/{projectId}/storage/token/{region} operation.
//
// This endpoint will get temporary access information for a project storage given a region.
//
// GET /htc/projects/{projectId}/storage/token/{region}
func (c *Client) HtcProjectsProjectIdStorageTokenRegionGet(ctx context.Context, params HtcProjectsProjectIdStorageTokenRegionGetParams) (HtcProjectsProjectIdStorageTokenRegionGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdStorageTokenRegionGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdStorageTokenRegionGet(ctx context.Context, params HtcProjectsProjectIdStorageTokenRegionGetParams) (res HtcProjectsProjectIdStorageTokenRegionGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage/token/"
	{
		// Encode "region" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "region",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Region)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokenRegionGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdStorageTokenRegionGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdStorageTokensGet invokes GET /htc/projects/{projectId}/storage/tokens operation.
//
// This endpoint will get temporary access information for all project storages.
//
// GET /htc/projects/{projectId}/storage/tokens
func (c *Client) HtcProjectsProjectIdStorageTokensGet(ctx context.Context, params HtcProjectsProjectIdStorageTokensGetParams) (HtcProjectsProjectIdStorageTokensGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdStorageTokensGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdStorageTokensGet(ctx context.Context, params HtcProjectsProjectIdStorageTokensGetParams) (res HtcProjectsProjectIdStorageTokensGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/storage/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokensGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdStorageTokensGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTaskRetentionPolicyDelete invokes DELETE /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint allows users to delete the task retention policy for the specified project. When a
// project-level policy is deleted, the auto-archival and auto-deletion behavior for tasks within the
// project will fall back to the workspace-level policy (if any). If no workspace-level policy is set,
//
//	tasks within the project will not be subject to any auto-archival or auto-deletion.
//
// DELETE /htc/projects/{projectId}/task-retention-policy
func (c *Client) HtcProjectsProjectIdTaskRetentionPolicyDelete(ctx context.Context, params HtcProjectsProjectIdTaskRetentionPolicyDeleteParams) (HtcProjectsProjectIdTaskRetentionPolicyDeleteRes, error) {
	res, err := c.sendHtcProjectsProjectIdTaskRetentionPolicyDelete(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTaskRetentionPolicyDelete(ctx context.Context, params HtcProjectsProjectIdTaskRetentionPolicyDeleteParams) (res HtcProjectsProjectIdTaskRetentionPolicyDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/task-retention-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTaskRetentionPolicyDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTaskRetentionPolicyGet invokes GET /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint is used to retrieve the current task retention policy of a specific project. The
// task retention policy is necessary in managing the lifecycle of tasks within a project. The task
// retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
// which an archived task is automatically deleted. Archived tasks can be unarchived during this
// period, protecting users from prematurely deleting task resources.
// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
// of inactivity after which an active task is automatically archived. This feature helps in keeping
// the project organized by archiving active tasks, ensuring that storage resources are freed
// optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.
// If no policy is set at the project level (i.e., the response is a 404), the policy at the
// workspace level will apply. If the policy has archiveAfter or deleteAfter set to 0, it means that
// auto-archival or auto-deletion is disabled at the project level and any workspace level policy is
// ignored.
//
// GET /htc/projects/{projectId}/task-retention-policy
func (c *Client) HtcProjectsProjectIdTaskRetentionPolicyGet(ctx context.Context, params HtcProjectsProjectIdTaskRetentionPolicyGetParams) (HtcProjectsProjectIdTaskRetentionPolicyGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTaskRetentionPolicyGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTaskRetentionPolicyGet(ctx context.Context, params HtcProjectsProjectIdTaskRetentionPolicyGetParams) (res HtcProjectsProjectIdTaskRetentionPolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/task-retention-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTaskRetentionPolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTaskRetentionPolicyPut invokes PUT /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint enables project administrators to define or update the task retention policy for a
// specific project. The task retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
// hours) after which an archived task is automatically deleted. This control allows for flexibility
// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
// from prematurely deleting task resources
// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
// duration (in hours) of inactivity after which an active task is automatically archived. This
// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
// resources are freed optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.If no policy is set at the project level, the workspace-level policy (if any) will
// be applied to the project.
//
// PUT /htc/projects/{projectId}/task-retention-policy
func (c *Client) HtcProjectsProjectIdTaskRetentionPolicyPut(ctx context.Context, request OptTaskRetentionPolicy, params HtcProjectsProjectIdTaskRetentionPolicyPutParams) (HtcProjectsProjectIdTaskRetentionPolicyPutRes, error) {
	res, err := c.sendHtcProjectsProjectIdTaskRetentionPolicyPut(ctx, request, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTaskRetentionPolicyPut(ctx context.Context, request OptTaskRetentionPolicy, params HtcProjectsProjectIdTaskRetentionPolicyPutParams) (res HtcProjectsProjectIdTaskRetentionPolicyPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/task-retention-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHtcProjectsProjectIdTaskRetentionPolicyPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyPut", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTaskRetentionPolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdDelete invokes DELETE /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint will delete a task by ID.
//
// DELETE /htc/projects/{projectId}/tasks/{taskId}
func (c *Client) HtcProjectsProjectIdTasksTaskIdDelete(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdDeleteParams) (HtcProjectsProjectIdTasksTaskIdDeleteRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdDelete(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdDelete(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdDeleteParams) (res HtcProjectsProjectIdTasksTaskIdDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdGet invokes GET /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint will get a task by ID.
//
// GET /htc/projects/{projectId}/tasks/{taskId}
func (c *Client) HtcProjectsProjectIdTasksTaskIdGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGetParams) (HtcProjectsProjectIdTasksTaskIdGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGetParams) (res HtcProjectsProjectIdTasksTaskIdGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics operation.
//
// This endpoint will get job status summary statistics for each group in a task.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics
func (c *Client) HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams) (HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams) (res HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/group-summary-statistics"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "group" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.Group != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.Group {
						if err := func() error {
							return e.EncodeValue(conv.StringToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdGroupsGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/groups operation.
//
// This endpoint will get task groups.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/groups
func (c *Client) HtcProjectsProjectIdTasksTaskIdGroupsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGroupsGetParams) (HtcProjectsProjectIdTasksTaskIdGroupsGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdGroupsGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdGroupsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdGroupsGetParams) (res HtcProjectsProjectIdTasksTaskIdGroupsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGroupsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdGroupsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/events operation.
//
// This endpoint will get events for a job.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/events
func (c *Client) HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetParams) (HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetParams) (res HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [7]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/jobs/"
	{
		// Encode "jobId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "jobId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.JobId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	pathParts[6] = "/events"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "pageIndex" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageIndex",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageIndex.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "pageSize" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "pageSize",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdPatch invokes PATCH /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint allows for managing the lifecycle of tasks. Users may set the `LifecycleStatus` of
// an HTCTask in accordance with their data retention requirements.
// Archiving a Task: To archive an active task, submit a PATCH request with "lifecycleStatus":
// "ARCHIVED". This action is permissible only if the task is currently active and has no running
// jobs. Once archived, the task enters a state where it is no longer operational, but its data is
// retained. An archived task will be automatically scheduled for deletion after a period defined in
// the project's task retention policy.
// Unarchiving a Task: If a task is in an archived state and you wish to defer its automatic deletion,
//
//	you can restore it to an active state. To unarchive a task, PATCH it with "lifecycleStatus":
//
// "ACTIVE". This action reactivates the task, making it modifiable and operational again. Note that
// this action is only applicable to tasks in the ARCHIVED state.
// Restrictions: Tasks in a DELETED state are immutable and cannot be transitioned to any other state
// using this endpoint. Similarly, tasks can only be archived if they are in an ACTIVE state and do
// not have any running jobs.
//
// PATCH /htc/projects/{projectId}/tasks/{taskId}
func (c *Client) HtcProjectsProjectIdTasksTaskIdPatch(ctx context.Context, request OptHTCTaskUpdate, params HtcProjectsProjectIdTasksTaskIdPatchParams) (HtcProjectsProjectIdTasksTaskIdPatchRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdPatch(ctx, request, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdPatch(ctx context.Context, request OptHTCTaskUpdate, params HtcProjectsProjectIdTasksTaskIdPatchParams) (res HtcProjectsProjectIdTasksTaskIdPatchRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHtcProjectsProjectIdTasksTaskIdPatchRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdPatch", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdPatchResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url operation.
//
// This endpoint will get a presigned url for task storage.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url
func (c *Client) HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams) (HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams) (res HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/storage/presigned-url"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "filePath" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "filePath",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.FilePath))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage operation.
//
// This endpoint will get temporary access information for all task storages.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage
func (c *Client) HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams) (HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams) (res HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/storage/regional-storage"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdStorageTokenGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/token operation.
//
// This endpoint will get temporary access information for a task storage.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token
func (c *Client) HtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokenGetParams) (HtcProjectsProjectIdTasksTaskIdStorageTokenGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokenGetParams) (res HtcProjectsProjectIdTasksTaskIdStorageTokenGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/storage/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokenGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokenGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region} operation.
//
// This endpoint will get temporary access information for a task storage given a region.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region}
func (c *Client) HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams) (HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams) (res HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [6]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/storage/token/"
	{
		// Encode "region" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "region",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Region)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcProjectsProjectIdTasksTaskIdStorageTokensGet invokes GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens operation.
//
// This endpoint will get temporary access information for all task storages.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens
func (c *Client) HtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokensGetParams) (HtcProjectsProjectIdTasksTaskIdStorageTokensGetRes, error) {
	res, err := c.sendHtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx context.Context, params HtcProjectsProjectIdTasksTaskIdStorageTokensGetParams) (res HtcProjectsProjectIdTasksTaskIdStorageTokensGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/storage/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokensGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokensGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcRegionsGet invokes GET /htc/regions operation.
//
// This endpoint will get HTC region settings for all regions.
//
// GET /htc/regions
func (c *Client) HtcRegionsGet(ctx context.Context, params HtcRegionsGetParams) (HtcRegionsGetRes, error) {
	res, err := c.sendHtcRegionsGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcRegionsGet(ctx context.Context, params HtcRegionsGetParams) (res HtcRegionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/htc/regions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "cloudProvider" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "cloudProvider",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CloudProvider.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "enabled" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "enabled",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Enabled.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcRegionsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcRegionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcRegionsRegionGet invokes GET /htc/regions/{region} operation.
//
// This endpoint will get HTC region settings for a specific region.
//
// GET /htc/regions/{region}
func (c *Client) HtcRegionsRegionGet(ctx context.Context, params HtcRegionsRegionGetParams) (HtcRegionsRegionGetRes, error) {
	res, err := c.sendHtcRegionsRegionGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcRegionsRegionGet(ctx context.Context, params HtcRegionsRegionGetParams) (res HtcRegionsRegionGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/htc/regions/"
	{
		// Encode "region" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "region",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Region)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcRegionsRegionGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcRegionsRegionGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcStorageGet invokes GET /htc/storage operation.
//
// This endpoint will get storages in all enabled regions.
//
// GET /htc/storage
func (c *Client) HtcStorageGet(ctx context.Context) (HtcStorageGetRes, error) {
	res, err := c.sendHtcStorageGet(ctx)
	return res, err
}

func (c *Client) sendHtcStorageGet(ctx context.Context) (res HtcStorageGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/htc/storage"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcStorageGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcStorageGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcStorageRegionRegionGet invokes GET /htc/storage/region/{region} operation.
//
// This endpoint will get a storage for a region.
//
// GET /htc/storage/region/{region}
func (c *Client) HtcStorageRegionRegionGet(ctx context.Context, params HtcStorageRegionRegionGetParams) (HtcStorageRegionRegionGetRes, error) {
	res, err := c.sendHtcStorageRegionRegionGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcStorageRegionRegionGet(ctx context.Context, params HtcStorageRegionRegionGetParams) (res HtcStorageRegionRegionGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/htc/storage/region/"
	{
		// Encode "region" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "region",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.Region)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcStorageRegionRegionGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcStorageRegionRegionGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcWorkspacesWorkspaceIdDimensionsGet invokes GET /htc/workspaces/{workspaceId}/dimensions operation.
//
// This endpoint provides a comprehensive view of the various hardware configurations and
// environments available within a specific workspace. This read-only API is primarily designed for
// users who need to understand the different "dimensions" or attributes that describe the hardware
// and other aspects of job runs within their workspace. By offering insights into available
// environments, it aids users in selecting the most suitable configuration for their jobs,
// especially when performance testing across different hardware setups.
// Normal users can access this endpoint for the workspace they belong to
// Rescale personnel are required in order to modify any of these dimensions.
//
// GET /htc/workspaces/{workspaceId}/dimensions
func (c *Client) HtcWorkspacesWorkspaceIdDimensionsGet(ctx context.Context, params HtcWorkspacesWorkspaceIdDimensionsGetParams) (HtcWorkspacesWorkspaceIdDimensionsGetRes, error) {
	res, err := c.sendHtcWorkspacesWorkspaceIdDimensionsGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcWorkspacesWorkspaceIdDimensionsGet(ctx context.Context, params HtcWorkspacesWorkspaceIdDimensionsGetParams) (res HtcWorkspacesWorkspaceIdDimensionsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/workspaces/"
	{
		// Encode "workspaceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workspaceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkspaceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dimensions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdDimensionsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcWorkspacesWorkspaceIdDimensionsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcWorkspacesWorkspaceIdLimitsGet invokes GET /htc/workspaces/{workspaceId}/limits operation.
//
// This endpoint will get the resource limit applied to this workspace.
//
// GET /htc/workspaces/{workspaceId}/limits
func (c *Client) HtcWorkspacesWorkspaceIdLimitsGet(ctx context.Context, params HtcWorkspacesWorkspaceIdLimitsGetParams) (HtcWorkspacesWorkspaceIdLimitsGetRes, error) {
	res, err := c.sendHtcWorkspacesWorkspaceIdLimitsGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcWorkspacesWorkspaceIdLimitsGet(ctx context.Context, params HtcWorkspacesWorkspaceIdLimitsGetParams) (res HtcWorkspacesWorkspaceIdLimitsGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/workspaces/"
	{
		// Encode "workspaceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workspaceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkspaceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/limits"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdLimitsGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcWorkspacesWorkspaceIdLimitsGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet invokes GET /htc/workspaces/{workspaceId}/task-retention-policy operation.
//
// This endpoint is used to retrieve the current task retention policy of a specific Workspace. The
// task retention policy is necessary in managing the lifecycle of tasks within a Workspace. The task
// retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
// which an archived task is automatically deleted. Archived tasks can be unarchived during this
// period, protecting users from prematurely deleting task resources.
// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
// of inactivity after which an active task is automatically archived. This feature helps in keeping
// the project organized by archiving active tasks, ensuring that storage resources are freed
// optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.
//
// GET /htc/workspaces/{workspaceId}/task-retention-policy
func (c *Client) HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet(ctx context.Context, params HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetParams) (HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetRes, error) {
	res, err := c.sendHtcWorkspacesWorkspaceIdTaskRetentionPolicyGet(ctx, params)
	return res, err
}

func (c *Client) sendHtcWorkspacesWorkspaceIdTaskRetentionPolicyGet(ctx context.Context, params HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetParams) (res HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/workspaces/"
	{
		// Encode "workspaceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workspaceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkspaceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/task-retention-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut invokes PUT /htc/workspaces/{workspaceId}/task-retention-policy operation.
//
// This endpoint enables Workspace administrators to define or update the task retention policy for a
// specific workspace. The task retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
// hours) after which an archived task is automatically deleted. This control allows for flexibility
// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
// from prematurely deleting task resources
// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
// duration (in hours) of inactivity after which an active task is automatically archived. This
// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
// resources are freed optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a workspace's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting. The policy applies to all projects within the workspace that do not have their own
// project-level policy defined. If a project within the workspace has its own retention policy
// defined, the project-level policy takes precedence over the workspace-level policy.
//
// PUT /htc/workspaces/{workspaceId}/task-retention-policy
func (c *Client) HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut(ctx context.Context, request OptWorkspaceTaskRetentionPolicy, params HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutParams) (HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRes, error) {
	res, err := c.sendHtcWorkspacesWorkspaceIdTaskRetentionPolicyPut(ctx, request, params)
	return res, err
}

func (c *Client) sendHtcWorkspacesWorkspaceIdTaskRetentionPolicyPut(ctx context.Context, request OptWorkspaceTaskRetentionPolicy, params HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutParams) (res HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/htc/workspaces/"
	{
		// Encode "workspaceId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "workspaceId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.WorkspaceId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/task-retention-policy"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// OAuth2TokenPost invokes POST /oauth2/token operation.
//
// This endpoint will get an OAuth access token.
//
// POST /oauth2/token
func (c *Client) OAuth2TokenPost(ctx context.Context) (OAuth2TokenPostRes, error) {
	res, err := c.sendOAuth2TokenPost(ctx)
	return res, err
}

func (c *Client) sendOAuth2TokenPost(ctx context.Context) (res OAuth2TokenPostRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/oauth2/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeOAuth2TokenPostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitJobs invokes submitJobs operation.
//
// This endpoint will submit a batch of jobs for a task.
//
// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/batch
func (c *Client) SubmitJobs(ctx context.Context, request []HTCJobSubmitRequest, params SubmitJobsParams) (SubmitJobsRes, error) {
	res, err := c.sendSubmitJobs(ctx, request, params)
	return res, err
}

func (c *Client) sendSubmitJobs(ctx context.Context, request []HTCJobSubmitRequest, params SubmitJobsParams) (res SubmitJobsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [5]string
	pathParts[0] = "/htc/projects/"
	{
		// Encode "projectId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "projectId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ProjectId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tasks/"
	{
		// Encode "taskId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "taskId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TaskId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/jobs/batch"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "group" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "group",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Group.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitJobsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "SubmitJobs", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSubmitJobsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WellKnownJwksJSONGet invokes GET /.well-known/jwks.json operation.
//
// This endpoint will get the public keys used to verify JWT.
//
// GET /.well-known/jwks.json
func (c *Client) WellKnownJwksJSONGet(ctx context.Context) (WellKnownJwksJSONGetRes, error) {
	res, err := c.sendWellKnownJwksJSONGet(ctx)
	return res, err
}

func (c *Client) sendWellKnownJwksJSONGet(ctx context.Context) (res WellKnownJwksJSONGetRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/.well-known/jwks.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWellKnownJwksJSONGetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WhoAmI invokes whoAmI operation.
//
// This endpoint will get Rescale user information given a Rescale API key.
//
// GET /auth/whoami
func (c *Client) WhoAmI(ctx context.Context) (WhoAmIRes, error) {
	res, err := c.sendWhoAmI(ctx)
	return res, err
}

func (c *Client) sendWhoAmI(ctx context.Context) (res WhoAmIRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/auth/whoami"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securitySecurityScheme(ctx, "WhoAmI", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"SecurityScheme\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWhoAmIResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
