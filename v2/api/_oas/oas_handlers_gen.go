// Code generated by ogen, DO NOT EDIT.

package _oas

import (
	"context"
	"net/http"

	"github.com/go-faster/errors"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

func recordError(string, error) {}

// handleAuthTokenGetRequest handles GET /auth/token operation.
//
// This endpoint will get a JWT token given an API key.
//
// GET /auth/token
func (s *Server) handleAuthTokenGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AuthTokenGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "AuthTokenGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response AuthTokenGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AuthTokenGet",
			OperationSummary: "Get JWT Token",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = AuthTokenGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AuthTokenGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AuthTokenGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAuthTokenGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAuthTokenWhoamiGetRequest handles GET /auth/token/whoami operation.
//
// This endpoint will get a JWT token payload given a bearer token.
//
// GET /auth/token/whoami
func (s *Server) handleAuthTokenWhoamiGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AuthTokenWhoamiGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "AuthTokenWhoamiGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response AuthTokenWhoamiGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AuthTokenWhoamiGet",
			OperationSummary: "Get JWT Token Payload",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = AuthTokenWhoamiGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AuthTokenWhoamiGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AuthTokenWhoamiGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAuthTokenWhoamiGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleAuthWhoamiGetRequest handles GET /auth/whoami operation.
//
// This endpoint will get Rescale user information given a Rescale API key.
//
// GET /auth/whoami
func (s *Server) handleAuthWhoamiGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AuthWhoamiGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "AuthWhoamiGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response AuthWhoamiGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AuthWhoamiGet",
			OperationSummary: "Get Rescale User",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = AuthWhoamiGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AuthWhoamiGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AuthWhoamiGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAuthWhoamiGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcGcpClustersWorkspaceIdGetRequest handles GET /htc/gcp/clusters/{workspaceId} operation.
//
// This endpoint returns details about all GCP clusters that can run jobs for the specified HTC
// workspace.
//
// GET /htc/gcp/clusters/{workspaceId}
func (s *Server) handleHtcGcpClustersWorkspaceIdGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcGcpClustersWorkspaceIdGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcGcpClustersWorkspaceIdGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcGcpClustersWorkspaceIdGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcGcpClustersWorkspaceIdGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcGcpClustersWorkspaceIdGet",
			OperationSummary: "Get Status of GCP Cluster",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcGcpClustersWorkspaceIdGetParams
			Response = HtcGcpClustersWorkspaceIdGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcGcpClustersWorkspaceIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcGcpClustersWorkspaceIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcGcpClustersWorkspaceIdGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcGcpClustersWorkspaceIdGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcMetricsGetRequest handles GET /htc/metrics operation.
//
// Get all HTC Metrics for a workspace.
//
// GET /htc/metrics
func (s *Server) handleHtcMetricsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcMetricsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcMetricsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcMetricsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcMetricsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcMetricsGet",
			OperationSummary: "Get Metrics",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "Accept-Encoding",
					In:   "header",
				}: params.AcceptEncoding,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcMetricsGetParams
			Response = HtcMetricsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcMetricsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcMetricsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcMetricsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcMetricsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsGetRequest handles GET /htc/projects operation.
//
// This endpoint will get all projects.
//
// GET /htc/projects
func (s *Server) handleHtcProjectsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsGet",
			OperationSummary: "Get All Projects",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "onlyMyProjects",
					In:   "query",
				}: params.OnlyMyProjects,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsGetParams
			Response = HtcProjectsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsPostRequest handles POST /htc/projects operation.
//
// This endpoint will create a project. A project is a collection of tasks and container images used
// to run jobs. Several projects can belong to a single workspace.
//
// POST /htc/projects
func (s *Server) handleHtcProjectsPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsPost",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsPost", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	request, close, err := s.decodeHtcProjectsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsPost",
			OperationSummary: "Create Project",
			OperationID:      "",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptHTCProject
			Params   = struct{}
			Response = HtcProjectsPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsPost(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsPost(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdContainerRegistryImagesGetRequest handles GET /htc/projects/{projectId}/container-registry/images operation.
//
// This endpoint will list all images for a project.
//
// GET /htc/projects/{projectId}/container-registry/images
func (s *Server) handleHtcProjectsProjectIdContainerRegistryImagesGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdContainerRegistryImagesGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdContainerRegistryImagesGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdContainerRegistryImagesGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdContainerRegistryImagesGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdContainerRegistryImagesGet",
			OperationSummary: "Get All Images",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdContainerRegistryImagesGetParams
			Response = HtcProjectsProjectIdContainerRegistryImagesGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdContainerRegistryImagesGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdContainerRegistryImagesGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdContainerRegistryImagesGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdContainerRegistryImagesGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdContainerRegistryImagesImageNameGetRequest handles GET /htc/projects/{projectId}/container-registry/images/{imageName} operation.
//
// Retrieves the current status of an image across cloud providers. The status indicates whether the
// image is ready for use or still being processed. Returns READY when the image is available in all
// cloud providers, PENDING while the image is being replicated, and a 404 if the image does not
// exist.
//
// GET /htc/projects/{projectId}/container-registry/images/{imageName}
func (s *Server) handleHtcProjectsProjectIdContainerRegistryImagesImageNameGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdContainerRegistryImagesImageNameGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdContainerRegistryImagesImageNameGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdContainerRegistryImagesImageNameGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdContainerRegistryImagesImageNameGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdContainerRegistryImagesImageNameGet",
			OperationSummary: "Get image status",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "imageName",
					In:   "path",
				}: params.ImageName,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdContainerRegistryImagesImageNameGetParams
			Response = HtcProjectsProjectIdContainerRegistryImagesImageNameGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdContainerRegistryImagesImageNameGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdContainerRegistryImagesImageNameGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdContainerRegistryImagesImageNameGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdContainerRegistryImagesImageNameGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdContainerRegistryRepoRepoNamePostRequest handles POST /htc/projects/{projectId}/container-registry/repo/{repoName} operation.
//
// This endpoint will create a private container repository belonging to this project
// Private container registries are collections of repositories, and private repositories are
// collections of container images. These images are referenced when running jobs within this project.
//
//	In order to upload an image to a repository, you will need the `registryURI`, the
//
// `repositoryName`, and the token (see `/htc/projects/:projectId/container-registry/token`).
//
// POST /htc/projects/{projectId}/container-registry/repo/{repoName}
func (s *Server) handleHtcProjectsProjectIdContainerRegistryRepoRepoNamePostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdContainerRegistryRepoRepoNamePost",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdContainerRegistryRepoRepoNamePost", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdContainerRegistryRepoRepoNamePostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdContainerRegistryRepoRepoNamePostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdContainerRegistryRepoRepoNamePost",
			OperationSummary: "Create a Private Repo",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "repoName",
					In:   "path",
				}: params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdContainerRegistryRepoRepoNamePostParams
			Response = HtcProjectsProjectIdContainerRegistryRepoRepoNamePostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdContainerRegistryRepoRepoNamePostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdContainerRegistryRepoRepoNamePost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdContainerRegistryRepoRepoNamePost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdContainerRegistryRepoRepoNamePostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdContainerRegistryTokenGetRequest handles GET /htc/projects/{projectId}/container-registry/token operation.
//
// This endpoint will get a container registry authorization token.
// To use this token run `docker login --username AWS --password {TOKEN} {CONTAINER_REGISTRY_DOMAIN}`.
// e.g. `docker login --username AWS --password "eyJwYXlsb2FkIjoiZHhtSzJuQ0x..." 183929446192.dkr.ecr.
// us-west-2.amazonaws.com`.
//
// GET /htc/projects/{projectId}/container-registry/token
func (s *Server) handleHtcProjectsProjectIdContainerRegistryTokenGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdContainerRegistryTokenGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdContainerRegistryTokenGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdContainerRegistryTokenGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdContainerRegistryTokenGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdContainerRegistryTokenGet",
			OperationSummary: "Get Container Registry Token",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdContainerRegistryTokenGetParams
			Response = HtcProjectsProjectIdContainerRegistryTokenGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdContainerRegistryTokenGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdContainerRegistryTokenGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdContainerRegistryTokenGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdContainerRegistryTokenGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdDimensionsGetRequest handles GET /htc/projects/{projectId}/dimensions operation.
//
// This endpoint is designed to retrieve the current set of dimension combinations configured for a
// specific project so that users can understand the existing computing environment constraints of a
// project. It returns a list of dimension combinations such as pricing priority, geographical region,
//
//	compute scaling policy, and hyperthreading options.
//
// Any user who _belongs to the workspace this project belongs to_ can use this endpoint to verify or
// audit the current configuration of a project. This can be helpful in ensuring that the project's
// settings align with expectations.
// The payload also includes a read-only set of `derived` dimensions which help describe the
// currently configured `machineType`.
//
// GET /htc/projects/{projectId}/dimensions
func (s *Server) handleHtcProjectsProjectIdDimensionsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdDimensionsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdDimensionsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdDimensionsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdDimensionsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdDimensionsGet",
			OperationSummary: "Get Project Dimensions",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdDimensionsGetParams
			Response = HtcProjectsProjectIdDimensionsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdDimensionsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdDimensionsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdDimensionsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdDimensionsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdDimensionsPutRequest handles PUT /htc/projects/{projectId}/dimensions operation.
//
// This endpoint allows _workspace_, _organization_, and _Rescale administrators_ to _create_,
// _update_, or _delete_ the dimension combinations for a project. It accepts a list of dimension
// combinations, each specifying a unique set of computing environment attributes to tailor the
// computing environment(s) of a project to match specific job requirements.
// For example, a projectâ€™s dimensions can be configured to require jobs to run on a particular
// type of processor architecture, within a certain region, and with or without hyperthreading.
// It's important to note that the dimensions set through this endpoint must align with the available
// dimensions at the workspace level.
// **In the event that a project's dimension requirements need to be reset to allow for a broader
// range of job types, sending an empty list to this endpoint will remove all existing dimension
// restrictions, returning the project to a state where it can accommodate any dimension available in
// the workspace.**.
//
// PUT /htc/projects/{projectId}/dimensions
func (s *Server) handleHtcProjectsProjectIdDimensionsPutRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdDimensionsPut",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdDimensionsPut", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdDimensionsPutParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdDimensionsPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdDimensionsPutRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdDimensionsPut",
			OperationSummary: "Modify Project Dimensions",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = []HTCComputeEnvironment
			Params   = HtcProjectsProjectIdDimensionsPutParams
			Response = HtcProjectsProjectIdDimensionsPutRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdDimensionsPutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdDimensionsPut(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdDimensionsPut(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdDimensionsPutResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdGetRequest handles GET /htc/projects/{projectId} operation.
//
// This endpoint will get a project by id.
//
// GET /htc/projects/{projectId}
func (s *Server) handleHtcProjectsProjectIdGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdGet",
			OperationSummary: "Get Project",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdGetParams
			Response = HtcProjectsProjectIdGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsDeleteRequest handles DELETE /htc/projects/{projectId}/limits operation.
//
// This endpoint will remove all resource limits associated with this project.
// Any jobs `SUBMITTED_TO_RESCALE` will transition to `SUBMITTED_TO_PROVIDER` if no other limits apply.
//
// DELETE /htc/projects/{projectId}/limits
func (s *Server) handleHtcProjectsProjectIdLimitsDeleteRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdLimitsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsDelete",
			OperationSummary: "Delete Project Limits",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdLimitsDeleteParams
			Response = HtcProjectsProjectIdLimitsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsGetRequest handles GET /htc/projects/{projectId}/limits operation.
//
// This endpoint will list all resource limitations associated with this project.
// A job running in this project will be subject to all resulting limits as well as any associated
// with the workspace (see `/htc/workspaces/{workspaceId}/limits`).
//
// GET /htc/projects/{projectId}/limits
func (s *Server) handleHtcProjectsProjectIdLimitsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdLimitsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsGet",
			OperationSummary: "Get Project Limits",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdLimitsGetParams
			Response = HtcProjectsProjectIdLimitsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsIDDeleteRequest handles DELETE /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will remove a single resource limit associated with this project if it exists.
//
// DELETE /htc/projects/{projectId}/limits/{id}
func (s *Server) handleHtcProjectsProjectIdLimitsIDDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsIDDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsIDDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdLimitsIDDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsIDDelete",
			OperationSummary: "Delete a Project Limit",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdLimitsIDDeleteParams
			Response = HtcProjectsProjectIdLimitsIDDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsIDDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsIDDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsIDDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsIDDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsIDGetRequest handles GET /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will get either the `PROJECT_ADMIN` or `WORKSPACE_ADMIN` limit for this project.
//
// GET /htc/projects/{projectId}/limits/{id}
func (s *Server) handleHtcProjectsProjectIdLimitsIDGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsIDGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsIDGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdLimitsIDGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsIDGet",
			OperationSummary: "Get Project Limit",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdLimitsIDGetParams
			Response = HtcProjectsProjectIdLimitsIDGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsIDGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsIDGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsIDGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsIDGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsIDPatchRequest handles PATCH /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will update one of the existing resource limits associated with this project.
// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
// permissions are required to modify the `WORKSPACE_ADMIN` limit.
//
// PATCH /htc/projects/{projectId}/limits/{id}
func (s *Server) handleHtcProjectsProjectIdLimitsIDPatchRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsIDPatch",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDPatch", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsIDPatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdLimitsIDPatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdLimitsIDPatchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsIDPatch",
			OperationSummary: "Update Project Limit",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCLimitUpdate
			Params   = HtcProjectsProjectIdLimitsIDPatchParams
			Response = HtcProjectsProjectIdLimitsIDPatchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsIDPatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsIDPatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsIDPatch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsIDPatchResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsPostRequest handles POST /htc/projects/{projectId}/limits operation.
//
// This endpoint will add a new limit to this project or overwrite an existing limit if one already
// exists with the provided `modifierRole`.
// Jobs submitted to this project will only run when the active resource count falls below the
// minimum of all limits associated with this project.
// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
// permissions are required to modify the `WORKSPACE_ADMIN` limit.
//
// POST /htc/projects/{projectId}/limits
func (s *Server) handleHtcProjectsProjectIdLimitsPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsPost",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsPost", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdLimitsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdLimitsPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsPost",
			OperationSummary: "Create a Project Limit",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCLimitCreate
			Params   = HtcProjectsProjectIdLimitsPostParams
			Response = HtcProjectsProjectIdLimitsPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsPost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdPatchRequest handles PATCH /htc/projects/{projectId} operation.
//
// This endpoint allows for updating a project's regions.
//
// PATCH /htc/projects/{projectId}
func (s *Server) handleHtcProjectsProjectIdPatchRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdPatch",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdPatch", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdPatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdPatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdPatchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdPatch",
			OperationSummary: "Update Project Regions",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCProjectUpdate
			Params   = HtcProjectsProjectIdPatchParams
			Response = HtcProjectsProjectIdPatchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdPatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdPatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdPatch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdPatchResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStoragePresignedURLGetRequest handles GET /htc/projects/{projectId}/storage/presigned-url operation.
//
// This endpoint will get a presigned url for project storage.
//
// GET /htc/projects/{projectId}/storage/presigned-url
func (s *Server) handleHtcProjectsProjectIdStoragePresignedURLGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStoragePresignedURLGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStoragePresignedURLGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStoragePresignedURLGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStoragePresignedURLGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStoragePresignedURLGet",
			OperationSummary: "Get Project Storage Presigned URL",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "filePath",
					In:   "query",
				}: params.FilePath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStoragePresignedURLGetParams
			Response = HtcProjectsProjectIdStoragePresignedURLGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStoragePresignedURLGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStoragePresignedURLGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStoragePresignedURLGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStoragePresignedURLGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStorageTokenGetRequest handles GET /htc/projects/{projectId}/storage/token operation.
//
// This endpoint will get temporary access information for a project storage.
//
// GET /htc/projects/{projectId}/storage/token
func (s *Server) handleHtcProjectsProjectIdStorageTokenGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStorageTokenGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokenGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStorageTokenGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStorageTokenGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStorageTokenGet",
			OperationSummary: "Get Project Storage Token",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStorageTokenGetParams
			Response = HtcProjectsProjectIdStorageTokenGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStorageTokenGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStorageTokenGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStorageTokenGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStorageTokenGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStorageTokenRegionGetRequest handles GET /htc/projects/{projectId}/storage/token/{region} operation.
//
// This endpoint will get temporary access information for a project storage given a region.
//
// GET /htc/projects/{projectId}/storage/token/{region}
func (s *Server) handleHtcProjectsProjectIdStorageTokenRegionGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStorageTokenRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokenRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStorageTokenRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStorageTokenRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStorageTokenRegionGet",
			OperationSummary: "Get Project Storage Token for a Region",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "region",
					In:   "path",
				}: params.Region,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStorageTokenRegionGetParams
			Response = HtcProjectsProjectIdStorageTokenRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStorageTokenRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStorageTokenRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStorageTokenRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStorageTokenRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStorageTokensGetRequest handles GET /htc/projects/{projectId}/storage/tokens operation.
//
// This endpoint will get temporary access information for all project storages.
//
// GET /htc/projects/{projectId}/storage/tokens
func (s *Server) handleHtcProjectsProjectIdStorageTokensGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStorageTokensGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokensGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStorageTokensGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStorageTokensGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStorageTokensGet",
			OperationSummary: "Get All Project Storage Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStorageTokensGetParams
			Response = HtcProjectsProjectIdStorageTokensGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStorageTokensGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStorageTokensGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStorageTokensGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStorageTokensGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTaskRetentionPolicyDeleteRequest handles DELETE /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint allows users to delete the task retention policy for the specified project. When a
// project-level policy is deleted, the auto-archival and auto-deletion behavior for tasks within the
// project will fall back to the workspace-level policy (if any). If no workspace-level policy is set,
//
//	tasks within the project will not be subject to any auto-archival or auto-deletion.
//
// DELETE /htc/projects/{projectId}/task-retention-policy
func (s *Server) handleHtcProjectsProjectIdTaskRetentionPolicyDeleteRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTaskRetentionPolicyDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTaskRetentionPolicyDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTaskRetentionPolicyDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTaskRetentionPolicyDelete",
			OperationSummary: "Delete Project Task Retention Policy",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTaskRetentionPolicyDeleteParams
			Response = HtcProjectsProjectIdTaskRetentionPolicyDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTaskRetentionPolicyDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTaskRetentionPolicyDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTaskRetentionPolicyGetRequest handles GET /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint is used to retrieve the current task retention policy of a specific project. The
// task retention policy is necessary in managing the lifecycle of tasks within a project. The task
// retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
// which an archived task is automatically deleted. Archived tasks can be unarchived during this
// period, protecting users from prematurely deleting task resources.
// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
// of inactivity after which an active task is automatically archived. This feature helps in keeping
// the project organized by archiving active tasks, ensuring that storage resources are freed
// optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.
// If no policy is set at the project level (i.e., the response is a 404), the policy at the
// workspace level will apply. If the policy has archiveAfter or deleteAfter set to 0, it means that
// auto-archival or auto-deletion is disabled at the project level and any workspace level policy is
// ignored.
//
// GET /htc/projects/{projectId}/task-retention-policy
func (s *Server) handleHtcProjectsProjectIdTaskRetentionPolicyGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTaskRetentionPolicyGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTaskRetentionPolicyGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTaskRetentionPolicyGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTaskRetentionPolicyGet",
			OperationSummary: "Get Project Task Retention Policy",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTaskRetentionPolicyGetParams
			Response = HtcProjectsProjectIdTaskRetentionPolicyGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTaskRetentionPolicyGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTaskRetentionPolicyGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTaskRetentionPolicyPutRequest handles PUT /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint enables project administrators to define or update the task retention policy for a
// specific project. The task retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
// hours) after which an archived task is automatically deleted. This control allows for flexibility
// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
// from prematurely deleting task resources
// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
// duration (in hours) of inactivity after which an active task is automatically archived. This
// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
// resources are freed optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.If no policy is set at the project level, the workspace-level policy (if any) will
// be applied to the project.
//
// PUT /htc/projects/{projectId}/task-retention-policy
func (s *Server) handleHtcProjectsProjectIdTaskRetentionPolicyPutRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTaskRetentionPolicyPut",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyPut", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTaskRetentionPolicyPutParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdTaskRetentionPolicyPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdTaskRetentionPolicyPutRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTaskRetentionPolicyPut",
			OperationSummary: "Modify Project Task Retention Policy",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptTaskRetentionPolicy
			Params   = HtcProjectsProjectIdTaskRetentionPolicyPutParams
			Response = HtcProjectsProjectIdTaskRetentionPolicyPutRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTaskRetentionPolicyPutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyPut(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyPut(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTaskRetentionPolicyPutResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksGetRequest handles GET /htc/projects/{projectId}/tasks operation.
//
// This endpoint will get all tasks in a project.
//
// GET /htc/projects/{projectId}/tasks
func (s *Server) handleHtcProjectsProjectIdTasksGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksGet",
			OperationSummary: "Get All Tasks for a Project",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksGetParams
			Response = HtcProjectsProjectIdTasksGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksPostRequest handles POST /htc/projects/{projectId}/tasks operation.
//
// This endpoint will create a task for a project.
//
// POST /htc/projects/{projectId}/tasks
func (s *Server) handleHtcProjectsProjectIdTasksPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksPost",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksPost", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdTasksPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdTasksPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksPost",
			OperationSummary: "Create a Task",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCTask
			Params   = HtcProjectsProjectIdTasksPostParams
			Response = HtcProjectsProjectIdTasksPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksPost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdDeleteRequest handles DELETE /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint will delete a task by ID.
//
// DELETE /htc/projects/{projectId}/tasks/{taskId}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdDelete",
			OperationSummary: "Delete Task",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdDeleteParams
			Response = HtcProjectsProjectIdTasksTaskIdDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint will get a task by ID.
//
// GET /htc/projects/{projectId}/tasks/{taskId}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdGet",
			OperationSummary: "Get Task",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdGetParams
			Response = HtcProjectsProjectIdTasksTaskIdGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics operation.
//
// This endpoint will get job status summary statistics for each group in a task.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet",
			OperationSummary: "Get Task Group Summary Statistics",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams
			Response = HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdGroupsGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/groups operation.
//
// This endpoint will get task groups.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/groups
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdGroupsGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdGroupsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGroupsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdGroupsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdGroupsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdGroupsGet",
			OperationSummary: "Get Task Groups",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdGroupsGetParams
			Response = HtcProjectsProjectIdTasksTaskIdGroupsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdGroupsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdGroupsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdJobsBatchPostRequest handles POST /htc/projects/{projectId}/tasks/{taskId}/jobs/batch operation.
//
// This endpoint will submit a batch of jobs for a task.
//
// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/batch
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdJobsBatchPostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdJobsBatchPost",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdJobsBatchPost", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdJobsBatchPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdTasksTaskIdJobsBatchPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdTasksTaskIdJobsBatchPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdJobsBatchPost",
			OperationSummary: "Submit Jobs",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
			},
			Raw: r,
		}

		type (
			Request  = []HTCJobSubmitRequest
			Params   = HtcProjectsProjectIdTasksTaskIdJobsBatchPostParams
			Response = HtcProjectsProjectIdTasksTaskIdJobsBatchPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdJobsBatchPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsBatchPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsBatchPost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdJobsBatchPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdJobsCancelPostRequest handles POST /htc/projects/{projectId}/tasks/{taskId}/jobs/cancel operation.
//
// This endpoint will attempt to cancel submitted jobs.
// Note a 200 response status code does not mean all jobs were cancelled.
//
// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/cancel
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdJobsCancelPostRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdJobsCancelPost",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdJobsCancelPost", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdJobsCancelPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdJobsCancelPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdJobsCancelPost",
			OperationSummary: "Cancel Jobs",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdJobsCancelPostParams
			Response = HtcProjectsProjectIdTasksTaskIdJobsCancelPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdJobsCancelPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsCancelPost(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsCancelPost(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdJobsCancelPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdJobsGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/jobs operation.
//
// This endpoint will get all jobs for a task.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdJobsGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdJobsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdJobsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdJobsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdJobsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdJobsGet",
			OperationSummary: "Get All Jobs For a Task",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
				{
					Name: "jobId",
					In:   "query",
				}: params.JobId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "viewType",
					In:   "query",
				}: params.ViewType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdJobsGetParams
			Response = HtcProjectsProjectIdTasksTaskIdJobsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdJobsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdJobsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/events operation.
//
// This endpoint will get events for a job.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/events
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet",
			OperationSummary: "Get Job Events",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "jobId",
					In:   "path",
				}: params.JobId,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetParams
			Response = HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdJobsJobIdEventsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdJobsJobIdGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId} operation.
//
// This endpoint will get a job by id.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdJobsJobIdGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdJobsJobIdGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdJobsJobIdGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdJobsJobIdGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdJobsJobIdGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdJobsJobIdGet",
			OperationSummary: "Get Job",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "jobId",
					In:   "path",
				}: params.JobId,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdJobsJobIdGetParams
			Response = HtcProjectsProjectIdTasksTaskIdJobsJobIdGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdJobsJobIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsJobIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsJobIdGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdJobsJobIdGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/logs operation.
//
// This endpoint will get job logs.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/logs
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGet",
			OperationSummary: "Get Job Logs",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "jobId",
					In:   "path",
				}: params.JobId,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetParams
			Response = HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdJobsJobIdLogsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdPatchRequest handles PATCH /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint allows for managing the lifecycle of tasks. Users may set the `LifecycleStatus` of
// an HTCTask in accordance with their data retention requirements.
// Archiving a Task: To archive an active task, submit a PATCH request with "lifecycleStatus":
// "ARCHIVED". This action is permissible only if the task is currently active and has no running
// jobs. Once archived, the task enters a state where it is no longer operational, but its data is
// retained. An archived task will be automatically scheduled for deletion after a period defined in
// the project's task retention policy.
// Unarchiving a Task: If a task is in an archived state and you wish to defer its automatic deletion,
//
//	you can restore it to an active state. To unarchive a task, PATCH it with "lifecycleStatus":
//
// "ACTIVE". This action reactivates the task, making it modifiable and operational again. Note that
// this action is only applicable to tasks in the ARCHIVED state.
// Restrictions: Tasks in a DELETED state are immutable and cannot be transitioned to any other state
// using this endpoint. Similarly, tasks can only be archived if they are in an ACTIVE state and do
// not have any running jobs.
//
// PATCH /htc/projects/{projectId}/tasks/{taskId}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdPatchRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdPatch",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdPatch", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdPatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdTasksTaskIdPatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdTasksTaskIdPatchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdPatch",
			OperationSummary: "Archive or Unarchive a Task",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCTaskUpdate
			Params   = HtcProjectsProjectIdTasksTaskIdPatchParams
			Response = HtcProjectsProjectIdTasksTaskIdPatchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdPatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdPatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdPatch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdPatchResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url operation.
//
// This endpoint will get a presigned url for task storage.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet",
			OperationSummary: "Get Task Storage Presigned URL",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "filePath",
					In:   "query",
				}: params.FilePath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage operation.
//
// This endpoint will get temporary access information for all task storages.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet",
			OperationSummary: "Get All Task Storage Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageTokenGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/token operation.
//
// This endpoint will get temporary access information for a task storage.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageTokenGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageTokenGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokenGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokenGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageTokenGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageTokenGet",
			OperationSummary: "Get Task Storage Token",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageTokenGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageTokenGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageTokenGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageTokenGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region} operation.
//
// This endpoint will get temporary access information for a task storage given a region.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet",
			OperationSummary: "Get Task Storage Token for a Region",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "region",
					In:   "path",
				}: params.Region,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageTokensGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens operation.
//
// This endpoint will get temporary access information for all task storages.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageTokensGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageTokensGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokensGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokensGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageTokensGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageTokensGet",
			OperationSummary: "Get All Task Storage Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageTokensGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageTokensGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageTokensGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageTokensGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcRegionsGetRequest handles GET /htc/regions operation.
//
// This endpoint will get HTC region settings for all regions.
//
// GET /htc/regions
func (s *Server) handleHtcRegionsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcRegionsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcRegionsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcRegionsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcRegionsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcRegionsGet",
			OperationSummary: "Get Region Settings For All Regions",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "cloudProvider",
					In:   "query",
				}: params.CloudProvider,
				{
					Name: "enabled",
					In:   "query",
				}: params.Enabled,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcRegionsGetParams
			Response = HtcRegionsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcRegionsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcRegionsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcRegionsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcRegionsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcRegionsRegionGetRequest handles GET /htc/regions/{region} operation.
//
// This endpoint will get HTC region settings for a specific region.
//
// GET /htc/regions/{region}
func (s *Server) handleHtcRegionsRegionGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcRegionsRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcRegionsRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcRegionsRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcRegionsRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcRegionsRegionGet",
			OperationSummary: "Get Region Settings for a Region",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "region",
					In:   "path",
				}: params.Region,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcRegionsRegionGetParams
			Response = HtcRegionsRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcRegionsRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcRegionsRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcRegionsRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcRegionsRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcStorageGetRequest handles GET /htc/storage operation.
//
// This endpoint will get storages in all enabled regions.
//
// GET /htc/storage
func (s *Server) handleHtcStorageGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcStorageGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcStorageGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response HtcStorageGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcStorageGet",
			OperationSummary: "Get Regional Storages",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = HtcStorageGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcStorageGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcStorageGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcStorageGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcStorageRegionRegionGetRequest handles GET /htc/storage/region/{region} operation.
//
// This endpoint will get a storage for a region.
//
// GET /htc/storage/region/{region}
func (s *Server) handleHtcStorageRegionRegionGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcStorageRegionRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcStorageRegionRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcStorageRegionRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcStorageRegionRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcStorageRegionRegionGet",
			OperationSummary: "Get Regional Storage",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "region",
					In:   "path",
				}: params.Region,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcStorageRegionRegionGetParams
			Response = HtcStorageRegionRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcStorageRegionRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcStorageRegionRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcStorageRegionRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcStorageRegionRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcWorkspacesWorkspaceIdDimensionsGetRequest handles GET /htc/workspaces/{workspaceId}/dimensions operation.
//
// This endpoint provides a comprehensive view of the various hardware configurations and
// environments available within a specific workspace. This read-only API is primarily designed for
// users who need to understand the different "dimensions" or attributes that describe the hardware
// and other aspects of job runs within their workspace. By offering insights into available
// environments, it aids users in selecting the most suitable configuration for their jobs,
// especially when performance testing across different hardware setups.
// Normal users can access this endpoint for the workspace they belong to
// Rescale personnel are required in order to modify any of these dimensions.
//
// GET /htc/workspaces/{workspaceId}/dimensions
func (s *Server) handleHtcWorkspacesWorkspaceIdDimensionsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcWorkspacesWorkspaceIdDimensionsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdDimensionsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcWorkspacesWorkspaceIdDimensionsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcWorkspacesWorkspaceIdDimensionsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcWorkspacesWorkspaceIdDimensionsGet",
			OperationSummary: "Get Workspace Dimensions",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcWorkspacesWorkspaceIdDimensionsGetParams
			Response = HtcWorkspacesWorkspaceIdDimensionsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcWorkspacesWorkspaceIdDimensionsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcWorkspacesWorkspaceIdDimensionsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcWorkspacesWorkspaceIdDimensionsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcWorkspacesWorkspaceIdDimensionsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcWorkspacesWorkspaceIdLimitsGetRequest handles GET /htc/workspaces/{workspaceId}/limits operation.
//
// This endpoint will get the resource limit applied to this workspace.
//
// GET /htc/workspaces/{workspaceId}/limits
func (s *Server) handleHtcWorkspacesWorkspaceIdLimitsGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcWorkspacesWorkspaceIdLimitsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdLimitsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcWorkspacesWorkspaceIdLimitsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcWorkspacesWorkspaceIdLimitsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcWorkspacesWorkspaceIdLimitsGet",
			OperationSummary: "Get Workspace Limit",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcWorkspacesWorkspaceIdLimitsGetParams
			Response = HtcWorkspacesWorkspaceIdLimitsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcWorkspacesWorkspaceIdLimitsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcWorkspacesWorkspaceIdLimitsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcWorkspacesWorkspaceIdLimitsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcWorkspacesWorkspaceIdLimitsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcWorkspacesWorkspaceIdTaskRetentionPolicyGetRequest handles GET /htc/workspaces/{workspaceId}/task-retention-policy operation.
//
// This endpoint is used to retrieve the current task retention policy of a specific Workspace. The
// task retention policy is necessary in managing the lifecycle of tasks within a Workspace. The task
// retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
// which an archived task is automatically deleted. Archived tasks can be unarchived during this
// period, protecting users from prematurely deleting task resources.
// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
// of inactivity after which an active task is automatically archived. This feature helps in keeping
// the project organized by archiving active tasks, ensuring that storage resources are freed
// optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.
//
// GET /htc/workspaces/{workspaceId}/task-retention-policy
func (s *Server) handleHtcWorkspacesWorkspaceIdTaskRetentionPolicyGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet",
			OperationSummary: "Get Workspace Task Retention Policy",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetParams
			Response = HtcWorkspacesWorkspaceIdTaskRetentionPolicyGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcWorkspacesWorkspaceIdTaskRetentionPolicyGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcWorkspacesWorkspaceIdTaskRetentionPolicyGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRequest handles PUT /htc/workspaces/{workspaceId}/task-retention-policy operation.
//
// This endpoint enables Workspace administrators to define or update the task retention policy for a
// specific workspace. The task retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
// hours) after which an archived task is automatically deleted. This control allows for flexibility
// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
// from prematurely deleting task resources
// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
// duration (in hours) of inactivity after which an active task is automatically archived. This
// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
// resources are freed optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a workspace's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting. The policy applies to all projects within the workspace that do not have their own
// project-level policy defined. If a project within the workspace has its own retention policy
// defined, the project-level policy takes precedence over the workspace-level policy.
//
// PUT /htc/workspaces/{workspaceId}/task-retention-policy
func (s *Server) handleHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut",
			OperationSummary: "Modify Workspace Task Retention Policy",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = OptWorkspaceTaskRetentionPolicy
			Params   = HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutParams
			Response = HtcWorkspacesWorkspaceIdTaskRetentionPolicyPutRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcWorkspacesWorkspaceIdTaskRetentionPolicyPut(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcWorkspacesWorkspaceIdTaskRetentionPolicyPutResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuth2TokenPostRequest handles POST /oauth2/token operation.
//
// This endpoint will get an OAuth access token.
//
// POST /oauth2/token
func (s *Server) handleOAuth2TokenPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response OAuth2TokenPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "OAuth2TokenPost",
			OperationSummary: "Get OAuth Access Token",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = OAuth2TokenPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuth2TokenPost(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuth2TokenPost(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuth2TokenPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWellKnownJwksJSONGetRequest handles GET /.well-known/jwks.json operation.
//
// This endpoint will get the public keys used to verify JWT.
//
// GET /.well-known/jwks.json
func (s *Server) handleWellKnownJwksJSONGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response WellKnownJwksJSONGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WellKnownJwksJSONGet",
			OperationSummary: "Get JWKS",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = WellKnownJwksJSONGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WellKnownJwksJSONGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.WellKnownJwksJSONGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWellKnownJwksJSONGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
