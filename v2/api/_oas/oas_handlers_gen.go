// Code generated by ogen, DO NOT EDIT.

package _oas

import (
	"context"
	"net/http"

	"github.com/go-faster/errors"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

func recordError(string, error) {}

// handleAuthTokenWhoamiGetRequest handles GET /auth/token/whoami operation.
//
// This endpoint will get a JWT token payload given a bearer token.
//
// GET /auth/token/whoami
func (s *Server) handleAuthTokenWhoamiGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "AuthTokenWhoamiGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "AuthTokenWhoamiGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response AuthTokenWhoamiGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "AuthTokenWhoamiGet",
			OperationSummary: "Get JWT Token Payload",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = AuthTokenWhoamiGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.AuthTokenWhoamiGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.AuthTokenWhoamiGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeAuthTokenWhoamiGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCancelJobsRequest handles cancelJobs operation.
//
// This endpoint will attempt to cancel submitted jobs.
// Note a 200 response status code does not mean all jobs were cancelled.
//
// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/cancel
func (s *Server) handleCancelJobsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CancelJobs",
			ID:   "cancelJobs",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "CancelJobs", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeCancelJobsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CancelJobsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CancelJobs",
			OperationSummary: "Cancel Jobs",
			OperationID:      "cancelJobs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CancelJobsParams
			Response = CancelJobsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCancelJobsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CancelJobs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CancelJobs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCancelJobsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateProjectRequest handles createProject operation.
//
// This endpoint will create a project. A project is a collection of tasks and container images used
// to run jobs. Several projects can belong to a single workspace.
//
// POST /htc/projects
func (s *Server) handleCreateProjectRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateProject",
			ID:   "createProject",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "CreateProject", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	request, close, err := s.decodeCreateProjectRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateProjectRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateProject",
			OperationSummary: "Create Project",
			OperationID:      "createProject",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = OptHTCProject
			Params   = struct{}
			Response = CreateProjectRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateProject(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateProject(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateProjectResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateRepoRequest handles createRepo operation.
//
// This endpoint will create a private container repository belonging to this project
// Private container registries are collections of repositories, and private repositories are
// collections of container images. These images are referenced when running jobs within this project.
//
//	In order to upload an image to a repository, you will need the `registryURI`, the
//
// `repositoryName`, and the token (see `/htc/projects/:projectId/container-registry/token`).
//
// POST /htc/projects/{projectId}/container-registry/repo/{repoName}
func (s *Server) handleCreateRepoRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateRepo",
			ID:   "createRepo",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "CreateRepo", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeCreateRepoParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response CreateRepoRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateRepo",
			OperationSummary: "Create a Private Repo",
			OperationID:      "createRepo",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "repoName",
					In:   "path",
				}: params.RepoName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = CreateRepoParams
			Response = CreateRepoRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCreateRepoParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateRepo(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateRepo(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateRepoResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateTaskRequest handles createTask operation.
//
// This endpoint will create a task for a project.
//
// POST /htc/projects/{projectId}/tasks
func (s *Server) handleCreateTaskRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "CreateTask",
			ID:   "createTask",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "CreateTask", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeCreateTaskParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeCreateTaskRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response CreateTaskRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "CreateTask",
			OperationSummary: "Create a Task",
			OperationID:      "createTask",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCTask
			Params   = CreateTaskParams
			Response = CreateTaskRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackCreateTaskParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateTask(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateTask(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeCreateTaskResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEventsRequest handles getEvents operation.
//
// This endpoint will get events for a job.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/events
func (s *Server) handleGetEventsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEvents",
			ID:   "getEvents",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetEvents", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetEventsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEventsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEvents",
			OperationSummary: "Get Job Events",
			OperationID:      "getEvents",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "jobId",
					In:   "path",
				}: params.JobId,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEventsParams
			Response = GetEventsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEventsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEvents(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEvents(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetGCPClustersRequest handles getGCPClusters operation.
//
// This endpoint returns details about all GCP clusters that can run jobs for the specified HTC
// workspace.
//
// GET /htc/gcp/clusters/{workspaceId}
func (s *Server) handleGetGCPClustersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetGCPClusters",
			ID:   "getGCPClusters",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetGCPClusters", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetGCPClustersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetGCPClustersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetGCPClusters",
			OperationSummary: "Get Status of GCP Cluster",
			OperationID:      "getGCPClusters",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetGCPClustersParams
			Response = GetGCPClustersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetGCPClustersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetGCPClusters(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetGCPClusters(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetGCPClustersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetImageRequest handles getImage operation.
//
// Retrieves the current status of an image across cloud providers. The status indicates whether the
// image is ready for use or still being processed. Returns READY when the image is available in all
// cloud providers, PENDING while the image is being replicated, and a 404 if the image does not
// exist.
//
// GET /htc/projects/{projectId}/container-registry/images/{imageName}
func (s *Server) handleGetImageRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetImage",
			ID:   "getImage",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetImage", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetImageParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetImageRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetImage",
			OperationSummary: "Get image status",
			OperationID:      "getImage",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "imageName",
					In:   "path",
				}: params.ImageName,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetImageParams
			Response = GetImageRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetImageParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetImage(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetImage(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetImageResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetImagesRequest handles getImages operation.
//
// This endpoint will list all images for a project.
//
// GET /htc/projects/{projectId}/container-registry/images
func (s *Server) handleGetImagesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetImages",
			ID:   "getImages",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetImages", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetImagesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetImagesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetImages",
			OperationSummary: "Get All Images",
			OperationID:      "getImages",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetImagesParams
			Response = GetImagesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetImagesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetImages(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetImages(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetImagesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetJobRequest handles getJob operation.
//
// This endpoint will get a job by id.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}
func (s *Server) handleGetJobRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetJob",
			ID:   "getJob",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetJob", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetJobParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetJobRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetJob",
			OperationSummary: "Get Job",
			OperationID:      "getJob",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "jobId",
					In:   "path",
				}: params.JobId,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetJobParams
			Response = GetJobRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetJobParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetJob(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetJob(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetJobResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetJobsRequest handles getJobs operation.
//
// This endpoint will get all jobs for a task.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs
func (s *Server) handleGetJobsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetJobs",
			ID:   "getJobs",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetJobs", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetJobsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetJobsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetJobs",
			OperationSummary: "Get All Jobs For a Task",
			OperationID:      "getJobs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
				{
					Name: "jobId",
					In:   "query",
				}: params.JobId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
				{
					Name: "status",
					In:   "query",
				}: params.Status,
				{
					Name: "viewType",
					In:   "query",
				}: params.ViewType,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetJobsParams
			Response = GetJobsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetJobsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetJobs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetJobs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetJobsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetLogsRequest handles getLogs operation.
//
// This endpoint will get job logs.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/jobs/{jobId}/logs
func (s *Server) handleGetLogsRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetLogs",
			ID:   "getLogs",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetLogs", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetLogsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetLogsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetLogs",
			OperationSummary: "Get Job Logs",
			OperationID:      "getLogs",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "jobId",
					In:   "path",
				}: params.JobId,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
				{
					Name: "sort",
					In:   "query",
				}: params.Sort,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetLogsParams
			Response = GetLogsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetLogsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetLogs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetLogs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetLogsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetMetricsRequest handles getMetrics operation.
//
// Get all HTC Metrics for a workspace.
//
// GET /htc/metrics
func (s *Server) handleGetMetricsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetMetrics",
			ID:   "getMetrics",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetMetrics", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetMetricsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetMetricsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetMetrics",
			OperationSummary: "Get Metrics",
			OperationID:      "getMetrics",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "Accept-Encoding",
					In:   "header",
				}: params.AcceptEncoding,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetMetricsParams
			Response = GetMetricsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetMetricsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetMetrics(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetMetrics(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetMetricsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetProjectRequest handles getProject operation.
//
// This endpoint will get a project by id.
//
// GET /htc/projects/{projectId}
func (s *Server) handleGetProjectRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetProject",
			ID:   "getProject",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetProject", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetProjectParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetProjectRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetProject",
			OperationSummary: "Get Project",
			OperationID:      "getProject",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetProjectParams
			Response = GetProjectRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetProjectParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetProject(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetProject(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetProjectResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetProjectDimensionsRequest handles getProjectDimensions operation.
//
// This endpoint is designed to retrieve the current set of dimension combinations configured for a
// specific project so that users can understand the existing computing environment constraints of a
// project. It returns a list of dimension combinations such as pricing priority, geographical region,
//
//	compute scaling policy, and hyperthreading options.
//
// Any user who _belongs to the workspace this project belongs to_ can use this endpoint to verify or
// audit the current configuration of a project. This can be helpful in ensuring that the project's
// settings align with expectations.
// The payload also includes a read-only set of `derived` dimensions which help describe the
// currently configured `machineType`.
//
// GET /htc/projects/{projectId}/dimensions
func (s *Server) handleGetProjectDimensionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetProjectDimensions",
			ID:   "getProjectDimensions",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetProjectDimensions", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetProjectDimensionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetProjectDimensionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetProjectDimensions",
			OperationSummary: "Get Project Dimensions",
			OperationID:      "getProjectDimensions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetProjectDimensionsParams
			Response = GetProjectDimensionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetProjectDimensionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetProjectDimensions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetProjectDimensions(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetProjectDimensionsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetProjectLimitsRequest handles getProjectLimits operation.
//
// This endpoint will list all resource limitations associated with this project.
// A job running in this project will be subject to all resulting limits as well as any associated
// with the workspace (see `/htc/workspaces/{workspaceId}/limits`).
//
// GET /htc/projects/{projectId}/limits
func (s *Server) handleGetProjectLimitsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetProjectLimits",
			ID:   "getProjectLimits",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetProjectLimits", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetProjectLimitsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetProjectLimitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetProjectLimits",
			OperationSummary: "Get Project Limits",
			OperationID:      "getProjectLimits",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetProjectLimitsParams
			Response = GetProjectLimitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetProjectLimitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetProjectLimits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetProjectLimits(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetProjectLimitsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetProjectsRequest handles getProjects operation.
//
// This endpoint will get all projects.
//
// GET /htc/projects
func (s *Server) handleGetProjectsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetProjects",
			ID:   "getProjects",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetProjects", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetProjectsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetProjectsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetProjects",
			OperationSummary: "Get All Projects",
			OperationID:      "getProjects",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "onlyMyProjects",
					In:   "query",
				}: params.OnlyMyProjects,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetProjectsParams
			Response = GetProjectsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetProjectsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetProjects(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetProjects(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetProjectsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetRegistryTokenRequest handles getRegistryToken operation.
//
// This endpoint will get a container registry authorization token.
// To use this token run `docker login --username AWS --password {TOKEN} {CONTAINER_REGISTRY_DOMAIN}`.
// e.g. `docker login --username AWS --password "eyJwYXlsb2FkIjoiZHhtSzJuQ0x..." 183929446192.dkr.ecr.
// us-west-2.amazonaws.com`.
//
// GET /htc/projects/{projectId}/container-registry/token
func (s *Server) handleGetRegistryTokenRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetRegistryToken",
			ID:   "getRegistryToken",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetRegistryToken", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetRegistryTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetRegistryTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetRegistryToken",
			OperationSummary: "Get Container Registry Token",
			OperationID:      "getRegistryToken",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetRegistryTokenParams
			Response = GetRegistryTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetRegistryTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetRegistryToken(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetRegistryToken(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetRegistryTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTaskRetentionPolicyRequest handles getTaskRetentionPolicy operation.
//
// This endpoint is used to retrieve the current task retention policy of a specific Workspace. The
// task retention policy is necessary in managing the lifecycle of tasks within a Workspace. The task
// retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
// which an archived task is automatically deleted. Archived tasks can be unarchived during this
// period, protecting users from prematurely deleting task resources.
// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
// of inactivity after which an active task is automatically archived. This feature helps in keeping
// the project organized by archiving active tasks, ensuring that storage resources are freed
// optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.
//
// GET /htc/workspaces/{workspaceId}/task-retention-policy
func (s *Server) handleGetTaskRetentionPolicyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTaskRetentionPolicy",
			ID:   "getTaskRetentionPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetTaskRetentionPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetTaskRetentionPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTaskRetentionPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTaskRetentionPolicy",
			OperationSummary: "Get Workspace Task Retention Policy",
			OperationID:      "getTaskRetentionPolicy",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTaskRetentionPolicyParams
			Response = GetTaskRetentionPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTaskRetentionPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTaskRetentionPolicy(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTaskRetentionPolicy(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTaskRetentionPolicyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTaskStatsRequest handles GetTaskStats operation.
//
// This endpoint will get task summary statistics.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/summary-statistics
func (s *Server) handleGetTaskStatsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTaskStats",
			ID:   "GetTaskStats",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetTaskStats", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetTaskStatsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTaskStatsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTaskStats",
			OperationSummary: "Get Task Summary Statistics",
			OperationID:      "GetTaskStats",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTaskStatsParams
			Response = GetTaskStatsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTaskStatsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTaskStats(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTaskStats(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTaskStatsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTasksRequest handles getTasks operation.
//
// This endpoint will get all tasks in a project.
//
// GET /htc/projects/{projectId}/tasks
func (s *Server) handleGetTasksRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetTasks",
			ID:   "getTasks",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetTasks", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetTasksParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTasksRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetTasks",
			OperationSummary: "Get All Tasks for a Project",
			OperationID:      "getTasks",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTasksParams
			Response = GetTasksRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTasksParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetTasks(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetTasks(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTasksResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetTokenRequest handles getToken operation.
//
// This endpoint will get a JWT token given an API key.
//
// GET /auth/token
func (s *Server) handleGetTokenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetToken",
			ID:   "getToken",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetToken", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetTokenParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetTokenRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetToken",
			OperationSummary: "Get JWT Token",
			OperationID:      "getToken",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "X-Rescale-Environment",
					In:   "header",
				}: params.XRescaleEnvironment,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetTokenParams
			Response = GetTokenRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetTokenParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetToken(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetToken(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWorkspaceDimensionsRequest handles getWorkspaceDimensions operation.
//
// This endpoint provides a comprehensive view of the various hardware configurations and
// environments available within a specific workspace. This read-only API is primarily designed for
// users who need to understand the different "dimensions" or attributes that describe the hardware
// and other aspects of job runs within their workspace. By offering insights into available
// environments, it aids users in selecting the most suitable configuration for their jobs,
// especially when performance testing across different hardware setups.
// Normal users can access this endpoint for the workspace they belong to
// Rescale personnel are required in order to modify any of these dimensions.
//
// GET /htc/workspaces/{workspaceId}/dimensions
func (s *Server) handleGetWorkspaceDimensionsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWorkspaceDimensions",
			ID:   "getWorkspaceDimensions",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetWorkspaceDimensions", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWorkspaceDimensionsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWorkspaceDimensionsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWorkspaceDimensions",
			OperationSummary: "Get Workspace Dimensions",
			OperationID:      "getWorkspaceDimensions",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWorkspaceDimensionsParams
			Response = GetWorkspaceDimensionsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWorkspaceDimensionsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWorkspaceDimensions(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWorkspaceDimensions(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWorkspaceDimensionsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWorkspaceLimitsRequest handles getWorkspaceLimits operation.
//
// This endpoint will get the resource limit applied to this workspace.
//
// GET /htc/workspaces/{workspaceId}/limits
func (s *Server) handleGetWorkspaceLimitsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWorkspaceLimits",
			ID:   "getWorkspaceLimits",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "GetWorkspaceLimits", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWorkspaceLimitsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWorkspaceLimitsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWorkspaceLimits",
			OperationSummary: "Get Workspace Limit",
			OperationID:      "getWorkspaceLimits",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWorkspaceLimitsParams
			Response = GetWorkspaceLimitsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWorkspaceLimitsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWorkspaceLimits(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWorkspaceLimits(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWorkspaceLimitsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdDimensionsPutRequest handles PUT /htc/projects/{projectId}/dimensions operation.
//
// This endpoint allows _workspace_, _organization_, and _Rescale administrators_ to _create_,
// _update_, or _delete_ the dimension combinations for a project. It accepts a list of dimension
// combinations, each specifying a unique set of computing environment attributes to tailor the
// computing environment(s) of a project to match specific job requirements.
// For example, a project’s dimensions can be configured to require jobs to run on a particular
// type of processor architecture, within a certain region, and with or without hyperthreading.
// It's important to note that the dimensions set through this endpoint must align with the available
// dimensions at the workspace level.
// **In the event that a project's dimension requirements need to be reset to allow for a broader
// range of job types, sending an empty list to this endpoint will remove all existing dimension
// restrictions, returning the project to a state where it can accommodate any dimension available in
// the workspace.**.
//
// PUT /htc/projects/{projectId}/dimensions
func (s *Server) handleHtcProjectsProjectIdDimensionsPutRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdDimensionsPut",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdDimensionsPut", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdDimensionsPutParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdDimensionsPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdDimensionsPutRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdDimensionsPut",
			OperationSummary: "Modify Project Dimensions",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = []HTCComputeEnvironment
			Params   = HtcProjectsProjectIdDimensionsPutParams
			Response = HtcProjectsProjectIdDimensionsPutRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdDimensionsPutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdDimensionsPut(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdDimensionsPut(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdDimensionsPutResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsDeleteRequest handles DELETE /htc/projects/{projectId}/limits operation.
//
// This endpoint will remove all resource limits associated with this project.
// Any jobs `SUBMITTED_TO_RESCALE` will transition to `SUBMITTED_TO_PROVIDER` if no other limits apply.
//
// DELETE /htc/projects/{projectId}/limits
func (s *Server) handleHtcProjectsProjectIdLimitsDeleteRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdLimitsDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsDelete",
			OperationSummary: "Delete Project Limits",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdLimitsDeleteParams
			Response = HtcProjectsProjectIdLimitsDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsIDDeleteRequest handles DELETE /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will remove a single resource limit associated with this project if it exists.
//
// DELETE /htc/projects/{projectId}/limits/{id}
func (s *Server) handleHtcProjectsProjectIdLimitsIDDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsIDDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsIDDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdLimitsIDDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsIDDelete",
			OperationSummary: "Delete a Project Limit",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdLimitsIDDeleteParams
			Response = HtcProjectsProjectIdLimitsIDDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsIDDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsIDDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsIDDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsIDDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsIDGetRequest handles GET /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will get either the `PROJECT_ADMIN` or `WORKSPACE_ADMIN` limit for this project.
//
// GET /htc/projects/{projectId}/limits/{id}
func (s *Server) handleHtcProjectsProjectIdLimitsIDGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsIDGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsIDGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdLimitsIDGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsIDGet",
			OperationSummary: "Get Project Limit",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdLimitsIDGetParams
			Response = HtcProjectsProjectIdLimitsIDGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsIDGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsIDGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsIDGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsIDGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsIDPatchRequest handles PATCH /htc/projects/{projectId}/limits/{id} operation.
//
// This endpoint will update one of the existing resource limits associated with this project.
// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
// permissions are required to modify the `WORKSPACE_ADMIN` limit.
//
// PATCH /htc/projects/{projectId}/limits/{id}
func (s *Server) handleHtcProjectsProjectIdLimitsIDPatchRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsIDPatch",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsIDPatch", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsIDPatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdLimitsIDPatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdLimitsIDPatchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsIDPatch",
			OperationSummary: "Update Project Limit",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCLimitUpdate
			Params   = HtcProjectsProjectIdLimitsIDPatchParams
			Response = HtcProjectsProjectIdLimitsIDPatchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsIDPatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsIDPatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsIDPatch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsIDPatchResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdLimitsPostRequest handles POST /htc/projects/{projectId}/limits operation.
//
// This endpoint will add a new limit to this project or overwrite an existing limit if one already
// exists with the provided `modifierRole`.
// Jobs submitted to this project will only run when the active resource count falls below the
// minimum of all limits associated with this project.
// Any user who belongs the project's workspace can modify the `PROJECT_ADMIN` limit. Higher
// permissions are required to modify the `WORKSPACE_ADMIN` limit.
//
// POST /htc/projects/{projectId}/limits
func (s *Server) handleHtcProjectsProjectIdLimitsPostRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdLimitsPost",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdLimitsPost", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdLimitsPostParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdLimitsPostRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdLimitsPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdLimitsPost",
			OperationSummary: "Create a Project Limit",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCLimitCreate
			Params   = HtcProjectsProjectIdLimitsPostParams
			Response = HtcProjectsProjectIdLimitsPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdLimitsPostParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdLimitsPost(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdLimitsPost(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdLimitsPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdPatchRequest handles PATCH /htc/projects/{projectId} operation.
//
// This endpoint allows for updating a project's regions.
//
// PATCH /htc/projects/{projectId}
func (s *Server) handleHtcProjectsProjectIdPatchRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdPatch",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdPatch", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdPatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdPatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdPatchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdPatch",
			OperationSummary: "Update Project Regions",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCProjectUpdate
			Params   = HtcProjectsProjectIdPatchParams
			Response = HtcProjectsProjectIdPatchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdPatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdPatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdPatch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdPatchResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStoragePresignedURLGetRequest handles GET /htc/projects/{projectId}/storage/presigned-url operation.
//
// This endpoint will get a presigned url for project storage.
//
// GET /htc/projects/{projectId}/storage/presigned-url
func (s *Server) handleHtcProjectsProjectIdStoragePresignedURLGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStoragePresignedURLGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStoragePresignedURLGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStoragePresignedURLGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStoragePresignedURLGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStoragePresignedURLGet",
			OperationSummary: "Get Project Storage Presigned URL",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "filePath",
					In:   "query",
				}: params.FilePath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStoragePresignedURLGetParams
			Response = HtcProjectsProjectIdStoragePresignedURLGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStoragePresignedURLGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStoragePresignedURLGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStoragePresignedURLGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStoragePresignedURLGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStorageTokenGetRequest handles GET /htc/projects/{projectId}/storage/token operation.
//
// This endpoint will get temporary access information for a project storage.
//
// GET /htc/projects/{projectId}/storage/token
func (s *Server) handleHtcProjectsProjectIdStorageTokenGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStorageTokenGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokenGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStorageTokenGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStorageTokenGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStorageTokenGet",
			OperationSummary: "Get Project Storage Token",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStorageTokenGetParams
			Response = HtcProjectsProjectIdStorageTokenGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStorageTokenGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStorageTokenGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStorageTokenGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStorageTokenGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStorageTokenRegionGetRequest handles GET /htc/projects/{projectId}/storage/token/{region} operation.
//
// This endpoint will get temporary access information for a project storage given a region.
//
// GET /htc/projects/{projectId}/storage/token/{region}
func (s *Server) handleHtcProjectsProjectIdStorageTokenRegionGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStorageTokenRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokenRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStorageTokenRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStorageTokenRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStorageTokenRegionGet",
			OperationSummary: "Get Project Storage Token for a Region",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "region",
					In:   "path",
				}: params.Region,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStorageTokenRegionGetParams
			Response = HtcProjectsProjectIdStorageTokenRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStorageTokenRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStorageTokenRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStorageTokenRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStorageTokenRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdStorageTokensGetRequest handles GET /htc/projects/{projectId}/storage/tokens operation.
//
// This endpoint will get temporary access information for all project storages.
//
// GET /htc/projects/{projectId}/storage/tokens
func (s *Server) handleHtcProjectsProjectIdStorageTokensGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdStorageTokensGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdStorageTokensGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdStorageTokensGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdStorageTokensGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdStorageTokensGet",
			OperationSummary: "Get All Project Storage Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdStorageTokensGetParams
			Response = HtcProjectsProjectIdStorageTokensGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdStorageTokensGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdStorageTokensGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdStorageTokensGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdStorageTokensGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTaskRetentionPolicyDeleteRequest handles DELETE /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint allows users to delete the task retention policy for the specified project. When a
// project-level policy is deleted, the auto-archival and auto-deletion behavior for tasks within the
// project will fall back to the workspace-level policy (if any). If no workspace-level policy is set,
//
//	tasks within the project will not be subject to any auto-archival or auto-deletion.
//
// DELETE /htc/projects/{projectId}/task-retention-policy
func (s *Server) handleHtcProjectsProjectIdTaskRetentionPolicyDeleteRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTaskRetentionPolicyDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTaskRetentionPolicyDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTaskRetentionPolicyDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTaskRetentionPolicyDelete",
			OperationSummary: "Delete Project Task Retention Policy",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTaskRetentionPolicyDeleteParams
			Response = HtcProjectsProjectIdTaskRetentionPolicyDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTaskRetentionPolicyDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTaskRetentionPolicyDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTaskRetentionPolicyGetRequest handles GET /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint is used to retrieve the current task retention policy of a specific project. The
// task retention policy is necessary in managing the lifecycle of tasks within a project. The task
// retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field represents the duration (in hours) after
// which an archived task is automatically deleted. Archived tasks can be unarchived during this
// period, protecting users from prematurely deleting task resources.
// * **Auto-Archive After Inactivity**: The `archiveAfter` field represents the duration (in hours)
// of inactivity after which an active task is automatically archived. This feature helps in keeping
// the project organized by archiving active tasks, ensuring that storage resources are freed
// optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.
// If no policy is set at the project level (i.e., the response is a 404), the policy at the
// workspace level will apply. If the policy has archiveAfter or deleteAfter set to 0, it means that
// auto-archival or auto-deletion is disabled at the project level and any workspace level policy is
// ignored.
//
// GET /htc/projects/{projectId}/task-retention-policy
func (s *Server) handleHtcProjectsProjectIdTaskRetentionPolicyGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTaskRetentionPolicyGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTaskRetentionPolicyGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTaskRetentionPolicyGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTaskRetentionPolicyGet",
			OperationSummary: "Get Project Task Retention Policy",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTaskRetentionPolicyGetParams
			Response = HtcProjectsProjectIdTaskRetentionPolicyGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTaskRetentionPolicyGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTaskRetentionPolicyGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTaskRetentionPolicyPutRequest handles PUT /htc/projects/{projectId}/task-retention-policy operation.
//
// This endpoint enables project administrators to define or update the task retention policy for a
// specific project. The task retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
// hours) after which an archived task is automatically deleted. This control allows for flexibility
// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
// from prematurely deleting task resources
// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
// duration (in hours) of inactivity after which an active task is automatically archived. This
// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
// resources are freed optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a project's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting.If no policy is set at the project level, the workspace-level policy (if any) will
// be applied to the project.
//
// PUT /htc/projects/{projectId}/task-retention-policy
func (s *Server) handleHtcProjectsProjectIdTaskRetentionPolicyPutRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTaskRetentionPolicyPut",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTaskRetentionPolicyPut", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTaskRetentionPolicyPutParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdTaskRetentionPolicyPutRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdTaskRetentionPolicyPutRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTaskRetentionPolicyPut",
			OperationSummary: "Modify Project Task Retention Policy",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
			},
			Raw: r,
		}

		type (
			Request  = OptTaskRetentionPolicy
			Params   = HtcProjectsProjectIdTaskRetentionPolicyPutParams
			Response = HtcProjectsProjectIdTaskRetentionPolicyPutRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTaskRetentionPolicyPutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyPut(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTaskRetentionPolicyPut(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTaskRetentionPolicyPutResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdDeleteRequest handles DELETE /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint will delete a task by ID.
//
// DELETE /htc/projects/{projectId}/tasks/{taskId}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdDeleteRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdDelete",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdDelete", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdDeleteParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdDeleteRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdDelete",
			OperationSummary: "Delete Task",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdDeleteParams
			Response = HtcProjectsProjectIdTasksTaskIdDeleteRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdDeleteParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdDelete(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdDelete(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdDeleteResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint will get a task by ID.
//
// GET /htc/projects/{projectId}/tasks/{taskId}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdGet",
			OperationSummary: "Get Task",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdGetParams
			Response = HtcProjectsProjectIdTasksTaskIdGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics operation.
//
// This endpoint will get job status summary statistics for each group in a task.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/group-summary-statistics
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet",
			OperationSummary: "Get Task Group Summary Statistics",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams
			Response = HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdGroupSummaryStatisticsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdGroupsGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/groups operation.
//
// This endpoint will get task groups.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/groups
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdGroupsGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdGroupsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdGroupsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdGroupsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdGroupsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdGroupsGet",
			OperationSummary: "Get Task Groups",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "pageIndex",
					In:   "query",
				}: params.PageIndex,
				{
					Name: "pageSize",
					In:   "query",
				}: params.PageSize,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdGroupsGetParams
			Response = HtcProjectsProjectIdTasksTaskIdGroupsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdGroupsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdGroupsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdGroupsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdPatchRequest handles PATCH /htc/projects/{projectId}/tasks/{taskId} operation.
//
// This endpoint allows for managing the lifecycle of tasks. Users may set the `LifecycleStatus` of
// an HTCTask in accordance with their data retention requirements.
// Archiving a Task: To archive an active task, submit a PATCH request with "lifecycleStatus":
// "ARCHIVED". This action is permissible only if the task is currently active and has no running
// jobs. Once archived, the task enters a state where it is no longer operational, but its data is
// retained. An archived task will be automatically scheduled for deletion after a period defined in
// the project's task retention policy.
// Unarchiving a Task: If a task is in an archived state and you wish to defer its automatic deletion,
//
//	you can restore it to an active state. To unarchive a task, PATCH it with "lifecycleStatus":
//
// "ACTIVE". This action reactivates the task, making it modifiable and operational again. Note that
// this action is only applicable to tasks in the ARCHIVED state.
// Restrictions: Tasks in a DELETED state are immutable and cannot be transitioned to any other state
// using this endpoint. Similarly, tasks can only be archived if they are in an ACTIVE state and do
// not have any running jobs.
//
// PATCH /htc/projects/{projectId}/tasks/{taskId}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdPatchRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdPatch",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdPatch", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdPatchParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeHtcProjectsProjectIdTasksTaskIdPatchRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response HtcProjectsProjectIdTasksTaskIdPatchRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdPatch",
			OperationSummary: "Archive or Unarchive a Task",
			OperationID:      "",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = OptHTCTaskUpdate
			Params   = HtcProjectsProjectIdTasksTaskIdPatchParams
			Response = HtcProjectsProjectIdTasksTaskIdPatchRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdPatchParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdPatch(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdPatch(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdPatchResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url operation.
//
// This endpoint will get a presigned url for task storage.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/presigned-url
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet",
			OperationSummary: "Get Task Storage Presigned URL",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "filePath",
					In:   "query",
				}: params.FilePath,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStoragePresignedURLGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStoragePresignedURLGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage operation.
//
// This endpoint will get temporary access information for all task storages.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/regional-storage
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet",
			OperationSummary: "Get All Task Storage Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageRegionalStorageGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageTokenGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/token operation.
//
// This endpoint will get temporary access information for a task storage.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageTokenGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageTokenGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokenGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokenGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageTokenGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageTokenGet",
			OperationSummary: "Get Task Storage Token",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageTokenGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageTokenGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageTokenGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageTokenGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region} operation.
//
// This endpoint will get temporary access information for a task storage given a region.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/token/{region}
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRequest(args [3]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet",
			OperationSummary: "Get Task Storage Token for a Region",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "region",
					In:   "path",
				}: params.Region,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokenRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageTokenRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcProjectsProjectIdTasksTaskIdStorageTokensGetRequest handles GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens operation.
//
// This endpoint will get temporary access information for all task storages.
//
// GET /htc/projects/{projectId}/tasks/{taskId}/storage/tokens
func (s *Server) handleHtcProjectsProjectIdTasksTaskIdStorageTokensGetRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcProjectsProjectIdTasksTaskIdStorageTokensGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcProjectsProjectIdTasksTaskIdStorageTokensGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcProjectsProjectIdTasksTaskIdStorageTokensGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcProjectsProjectIdTasksTaskIdStorageTokensGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcProjectsProjectIdTasksTaskIdStorageTokensGet",
			OperationSummary: "Get All Task Storage Tokens",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcProjectsProjectIdTasksTaskIdStorageTokensGetParams
			Response = HtcProjectsProjectIdTasksTaskIdStorageTokensGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcProjectsProjectIdTasksTaskIdStorageTokensGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcProjectsProjectIdTasksTaskIdStorageTokensGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcProjectsProjectIdTasksTaskIdStorageTokensGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcRegionsGetRequest handles GET /htc/regions operation.
//
// This endpoint will get HTC region settings for all regions.
//
// GET /htc/regions
func (s *Server) handleHtcRegionsGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcRegionsGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcRegionsGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcRegionsGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcRegionsGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcRegionsGet",
			OperationSummary: "Get Region Settings For All Regions",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "cloudProvider",
					In:   "query",
				}: params.CloudProvider,
				{
					Name: "enabled",
					In:   "query",
				}: params.Enabled,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcRegionsGetParams
			Response = HtcRegionsGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcRegionsGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcRegionsGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcRegionsGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcRegionsGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcRegionsRegionGetRequest handles GET /htc/regions/{region} operation.
//
// This endpoint will get HTC region settings for a specific region.
//
// GET /htc/regions/{region}
func (s *Server) handleHtcRegionsRegionGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcRegionsRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcRegionsRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcRegionsRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcRegionsRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcRegionsRegionGet",
			OperationSummary: "Get Region Settings for a Region",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "region",
					In:   "path",
				}: params.Region,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcRegionsRegionGetParams
			Response = HtcRegionsRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcRegionsRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcRegionsRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcRegionsRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcRegionsRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcStorageGetRequest handles GET /htc/storage operation.
//
// This endpoint will get storages in all enabled regions.
//
// GET /htc/storage
func (s *Server) handleHtcStorageGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcStorageGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcStorageGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response HtcStorageGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcStorageGet",
			OperationSummary: "Get Regional Storages",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = HtcStorageGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcStorageGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcStorageGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcStorageGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleHtcStorageRegionRegionGetRequest handles GET /htc/storage/region/{region} operation.
//
// This endpoint will get a storage for a region.
//
// GET /htc/storage/region/{region}
func (s *Server) handleHtcStorageRegionRegionGetRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "HtcStorageRegionRegionGet",
			ID:   "",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "HtcStorageRegionRegionGet", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeHtcStorageRegionRegionGetParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response HtcStorageRegionRegionGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "HtcStorageRegionRegionGet",
			OperationSummary: "Get Regional Storage",
			OperationID:      "",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "region",
					In:   "path",
				}: params.Region,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = HtcStorageRegionRegionGetParams
			Response = HtcStorageRegionRegionGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackHtcStorageRegionRegionGetParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.HtcStorageRegionRegionGet(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.HtcStorageRegionRegionGet(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeHtcStorageRegionRegionGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleOAuth2TokenPostRequest handles POST /oauth2/token operation.
//
// This endpoint will get an OAuth access token.
//
// POST /oauth2/token
func (s *Server) handleOAuth2TokenPostRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response OAuth2TokenPostRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "OAuth2TokenPost",
			OperationSummary: "Get OAuth Access Token",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = OAuth2TokenPostRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.OAuth2TokenPost(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.OAuth2TokenPost(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeOAuth2TokenPostResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePutTaskRetentionPolicyRequest handles putTaskRetentionPolicy operation.
//
// This endpoint enables Workspace administrators to define or update the task retention policy for a
// specific workspace. The task retention policy includes two key aspects:
// * **Deletion Grace Period**: The `deleteAfter` field allows administrators to set the duration (in
// hours) after which an archived task is automatically deleted. This control allows for flexibility
// in managing the lifecycle of tasks, ensuring that data is retained for an adequate period before
// being permanently deleted. Archived tasks can be unarchived during this period, protecting users
// from prematurely deleting task resources
// * **Auto-Archive After Inactivity**: The `archiveAfter` field allows administrators to specify the
// duration (in hours) of inactivity after which an active task is automatically archived. This
// feature helps in keeping the project organized by archiving active tasks, ensuring that storage
// resources are freed optimistically.
// Setting either value to `0` will result in disabling of that feature. For example, a workspace's
// task retention policy with `deleteAfter` set to `0` will result in tasks within that project never
// auto-deleting. The policy applies to all projects within the workspace that do not have their own
// project-level policy defined. If a project within the workspace has its own retention policy
// defined, the project-level policy takes precedence over the workspace-level policy.
//
// PUT /htc/workspaces/{workspaceId}/task-retention-policy
func (s *Server) handlePutTaskRetentionPolicyRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PutTaskRetentionPolicy",
			ID:   "putTaskRetentionPolicy",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "PutTaskRetentionPolicy", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePutTaskRetentionPolicyParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePutTaskRetentionPolicyRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PutTaskRetentionPolicyRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PutTaskRetentionPolicy",
			OperationSummary: "Modify Workspace Task Retention Policy",
			OperationID:      "putTaskRetentionPolicy",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "workspaceId",
					In:   "path",
				}: params.WorkspaceId,
			},
			Raw: r,
		}

		type (
			Request  = OptWorkspaceTaskRetentionPolicy
			Params   = PutTaskRetentionPolicyParams
			Response = PutTaskRetentionPolicyRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPutTaskRetentionPolicyParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PutTaskRetentionPolicy(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PutTaskRetentionPolicy(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePutTaskRetentionPolicyResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleSubmitJobsRequest handles submitJobs operation.
//
// This endpoint will submit a batch of jobs for a task.
//
// POST /htc/projects/{projectId}/tasks/{taskId}/jobs/batch
func (s *Server) handleSubmitJobsRequest(args [2]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "SubmitJobs",
			ID:   "submitJobs",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "SubmitJobs", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeSubmitJobsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeSubmitJobsRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response SubmitJobsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "SubmitJobs",
			OperationSummary: "Submit Jobs",
			OperationID:      "submitJobs",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "projectId",
					In:   "path",
				}: params.ProjectId,
				{
					Name: "taskId",
					In:   "path",
				}: params.TaskId,
				{
					Name: "group",
					In:   "query",
				}: params.Group,
			},
			Raw: r,
		}

		type (
			Request  = []HTCJobSubmitRequest
			Params   = SubmitJobsParams
			Response = SubmitJobsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackSubmitJobsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.SubmitJobs(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.SubmitJobs(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeSubmitJobsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWellKnownJwksJSONGetRequest handles GET /.well-known/jwks.json operation.
//
// This endpoint will get the public keys used to verify JWT.
//
// GET /.well-known/jwks.json
func (s *Server) handleWellKnownJwksJSONGetRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err error
	)

	var response WellKnownJwksJSONGetRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WellKnownJwksJSONGet",
			OperationSummary: "Get JWKS",
			OperationID:      "",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = WellKnownJwksJSONGetRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WellKnownJwksJSONGet(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.WellKnownJwksJSONGet(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWellKnownJwksJSONGetResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleWhoAmIRequest handles whoAmI operation.
//
// This endpoint will get Rescale user information given a Rescale API key.
//
// GET /auth/whoami
func (s *Server) handleWhoAmIRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "WhoAmI",
			ID:   "whoAmI",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securitySecurityScheme(ctx, "WhoAmI", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "SecurityScheme",
					Err:              err,
				}
				defer recordError("Security:SecurityScheme", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}

	var response WhoAmIRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "WhoAmI",
			OperationSummary: "Get Rescale User",
			OperationID:      "whoAmI",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = WhoAmIRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.WhoAmI(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.WhoAmI(ctx)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeWhoAmIResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
